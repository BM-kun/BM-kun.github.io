<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gui入门</title>
      <link href="/2023/07/25/gui-ru-men/"/>
      <url>/2023/07/25/gui-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Git新手向"><a href="#Git新手向" class="headerlink" title="Git新手向"></a>Git新手向</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>Git是版本控制软件，而github是基于Git这个版本控制软件打造的网站。</p><p>Git的三个概念：commit提交、repository仓库、branch分支</p><p>何为版本控制软件：<a href="">仓库</a>中<a href="">多人</a>协同完成代码后提交<a href="">存档</a></p><p>目的：方便后悔，找回历史记录</p><h2 id="二、查看他人Github项目"><a href="#二、查看他人Github项目" class="headerlink" title="二、查看他人Github项目"></a>二、查看他人Github项目</h2><p>浏览他人github代码仓库时,code找到网址，然后再自己的工作文件夹中Git bash 命令<code>git clone 代码网址</code></p><ul><li>git clone   克隆项目</li><li>star   收藏</li><li>Readme.md  说明文档</li><li>LICENSE  许可证</li><li>issue  论坛                    </li></ul><h2 id="三、查找开源项目"><a href="#三、查找开源项目" class="headerlink" title="三、查找开源项目"></a>三、查找开源项目</h2><p>找开源项目的一些途径<br>• <a href="https://github.com/trending/">https://github.com/trending/</a><br>• <a href="https://github.com/521xueweihan/HelloGitHub">https://github.com/521xueweihan/HelloGitHub</a><br>• <a href="https://github.com/ruanyf/weekly">https://github.com/ruanyf/weekly</a><br>• <a href="https://www.zhihu.com/column/mm-fe">https://www.zhihu.com/column/mm-fe</a></p><p>特殊的查找资源小技巧-常用前缀后缀<br>• 找百科大全 awesome xxx<br>• 找例子 xxx sample<br>• 找空项目架子 xxx starter / xxx boilerplate<br>• 找教程  xxx tutorial</p><h2 id="四、Git操作"><a href="#四、Git操作" class="headerlink" title="四、Git操作"></a>四、Git操作</h2><p>git clone 下载下来的是仓库，有.git文件夹；download zip下载下来是单纯的文件夹</p><ul><li><p>克隆仓库：git clone &lt;git地址&gt;</p></li><li><p>初始化仓库：git init   建立.git文件夹</p></li><li><p>提交</p><p>![image-20230725115318390](E:\My Blog\Blog\source_posts\Gui入门.assets\image-20230725115318390.png)</p><ul><li><p>添加文件到暂存区：git add -A</p></li><li><p>把暂存区的文件提交到仓库：git commit -m “提交信息”  </p><p>或者vscode中的源代码管理 ctrl + enter</p></li><li><p>查看提交的历史记录：git log –stat   </p><p>或者在源代码管理区查看，一次提交都对应一个哈希值</p></li></ul></li><li><p>维护项目</p><ul><li><p>工作区回滚：git checkout <filename>  </filename></p><p>相当于ctrl + z  或者源代码管理区中的更改撤回按钮</p></li><li><p>撤销最后一次提交：git reset HEAD^1    </p><p>或者源代码管理区的undo commit</p></li></ul></li><li><p>分支</p><ul><li><p>以当前分支为基础新建分支：git checkout -b <branchname>  b为build</branchname></p></li><li><p>列举所有的分支：git branch</p></li><li><p>单纯地切换到某个分支：git checkout <branchname></branchname></p></li><li><p>删掉特定的分支：git branch -D <branchname></branchname></p></li><li><p>合并分支：git merge <branchname>  </branchname></p><p>git merge –abort  放弃本次合并</p></li></ul></li><li><p>Git远程仓库</p><ul><li>推送当前分支最新的提交到远程：git push </li><li>拉取远程分支最新的提交到本地：git pull</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python入门</title>
      <link href="/2023/07/11/python-ru-men/"/>
      <url>/2023/07/11/python-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础入门"><a href="#Python基础入门" class="headerlink" title="Python基础入门"></a>Python基础入门</h1><blockquote><p>笔记文档：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p></blockquote><p>python是一门解释型语言，先用解释器翻译为字节码，然后再由编译器编译为机器码，计算机才可以执行。（一般.exe文件就是机器码）</p><h2 id="创始人"><a href="#创始人" class="headerlink" title="创始人"></a>创始人</h2><p>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p><p>“*Python的创始人为<a href="">荷兰人</a>吉多·范罗苏姆(Guido van Rossum)*“</p><p>Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用<a href="">4</a>个空格的缩进。</p><p>在Python文件中，前面两行建议添加下面两行注释：</p><p>#!/usr/bin/env python3</p><p># -<em>- coding: utf-8 -</em>-</p><p>第一行注释，是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释，是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p><ul><li><p>0开头代表八进制数，0x开头代表16进制</p></li><li><p>很长的数可以用_分开，比如10_000_000_000；0xa1b2_c3d4</p></li><li><p>Python的整数，浮点数没有大小限制</p></li><li><p>浮点数可以这样表示：把10用e替代，1.23x10^9就是<code>1.23e9</code>或者<code>12.3e8</code>0.000012可以写成<code>1.2e-5</code></p></li><li><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p></li><li><p>如果字符串内部既包含<code>'</code>又包含<code>"</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p><pre class=" language-python"><code class="language-python"><span class="token string">'I\'m \"OK\"!'</span></code></pre><p>表示的字符串内容是：</p><pre class=" language-python"><code class="language-python">I'm <span class="token string">"OK"</span>!</code></pre></li><li><p>Python还允许用<code>r''</code>表示<code>''</code>内部的字符串默认不转义</p></li><li><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#格式化字符串%  和占位符 %s %d</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%2d-%02d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%.2f'</span> <span class="token operator">%</span> <span class="token number">3.1415926</span><span class="token punctuation">)</span>format格式化字符串<span class="token string">'Hello, {0}, 成绩提升了 {1:.1f}%'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span> <span class="token number">17.125</span><span class="token punctuation">)</span><span class="token string">'Hello, 小明, 成绩提升了 17.1%'</span></code></pre><p>f-string</p><p>最后一种格式化字符串的方法是使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>{xxx}</code>，就会以对应的变量替换：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> <span class="token number">2.5</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token operator">*</span> r <span class="token operator">**</span> <span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The area of a circle with radius {r} is {s:.2f}'</span><span class="token punctuation">)</span>The area of a circle <span class="token keyword">with</span> radius <span class="token number">2.5</span> <span class="token keyword">is</span> <span class="token number">19.62</span></code></pre><p>上述代码中，<code>{r}</code>被变量<code>r</code>的值替换，<code>{s:.2f}</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>{s:.2f}</code>的替换结果是<code>19.62</code>。</p></li><li><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>'''...'''</code>的格式表示多行内容</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token triple-quoted-string string">'''line1line2line3'''</span><span class="token punctuation">)</span>输出：line1line2line3</code></pre></li><li><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p></li><li><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p></li><li><p><a href="">变量</a>的概念基本上和初中代数的方程变量是一致的</p></li><li><p><code>=</code>是赋值语句</p><p>![py-var-code-1](E:\My Blog\Blog\source_posts\Python入门.assets\0.png)</p><p>b = a后：</p><p>![py-var-code-2](E:\My Blog\Blog\source_posts\Python入门.assets\0-16623065203103.png)</p></li><li><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，数据类型可以随时改变</p></li><li><p>除法有 <strong>/ 和</strong>// **地板除法两种。</p></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><a href=""><strong>集合推导式：</strong></a></li></ul><pre class=" language-python"><code class="language-python"><span class="token punctuation">{</span>s <span class="token keyword">for</span> s <span class="token keyword">in</span> <span class="token string">"fishc.com.cn"</span><span class="token punctuation">}</span></code></pre><blockquote><p>例子(这条格式快捷键 &gt; )</p></blockquote><p>![img](E:\My Blog\Blog\source_posts\Python入门.assets\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YiY57uP57qs6ICB5biI,size_20,color_FFFFFF,t_70,g_se,x_16.png)</p><blockquote><p>说明文档中函数（*others）支持多个参数；函数（other）只支持一个参数。</p></blockquote><p>可哈希的对象才能作为字典的键</p><p>可变的容器是不可哈希的；集合是可变的容器所以不可hash（）；frozenset是不变的容器，可哈希，可嵌套。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><strong>format：</strong>print( f’{sample}’)  把sample作为字符串输出</p></li><li><p>参数分为形参和实参</p></li><li><p>位置参数和关键字参数（参数多的时候用不混乱：(a=1;b=2)）.两个参数一起用时位置参数必须在关键字参数前面</p></li><li><p>默认参数即在定义参数时给了默认值，调用函数时如果没有这个参数则用默认值，有则覆盖默认值。默认参数放后边</p></li><li><p>help（）查看函数文档时候函数原型中（/），/左边的参数必须是位置参数，/右边随便</p><p>参数定义中<a href="">*</a>左边可以随便，右边必须是关键字参数：这个星号其实就是一个匿名的收集参数，后面不加参数名的话会被一起收进去</p></li><li><p>**<a href="">收集参数</a>*<em>：在形参的前面加一个星号（</em>）来表示，将多个参数打包进一个元组：tuple，后边必须是关键字参数，不然会被打包。比如format函数就是两种收集参数都有。</p><blockquote><p>两个星号收集参数是打包成字典，参数用a=1；b=2的键值对来表示</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token operator">*</span>b<span class="token punctuation">,</span><span class="token operator">**</span>c<span class="token punctuation">)</span>myfunc<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>x<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#综合</span></code></pre></li><li><p>函数return多个值其实是用元组进行打包，也可以拿来解包</p></li><li><p>解包参数：一个*把元组解包传入函数；**把字典解包传入函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span>    args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>myfunc<span class="token punctuation">(</span><span class="token operator">*</span>argc<span class="token punctuation">)</span>kwargs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>myfunc<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span></code></pre></li><li><p>作用域：</p><p>1.局部作用域：在函数中局部变量会覆盖全局变量</p><p>2.全局作用域</p></li><li><p>global语句：声明变量为全局变量</p></li><li><p>嵌套函数：只能在该函数中调用，外部无法访问</p></li><li><p>nonlocal语句：修改嵌套上一层的函数作用域变量；global则是修改全局变量</p></li><li><p>LEGB规则：local&lt;-enclose(嵌套外层)&lt;-global&lt;-build(内置作用域)</p><p>内置作用域就是python自带的关键字变量 比如str  起个同名的变量则覆盖原来的str</p><p><a href="">就近原则</a></p></li><li><p>闭包：</p><p>对于嵌套函数来说，嵌套外层作用域变量会保留下来，不会想局部作用域那样调用完就消失。*<a href="">内层函数能够记住外层函数作用域</a>*</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">funcA</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">funcB</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>​    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token operator">*</span>a<span class="token punctuation">)</span>  <span class="token keyword">return</span> funcBstate <span class="token operator">=</span> funcA<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#&lt;function funcA.&lt;locals>.funcB at 0x0000023DEE1C0EE0>  state得到得是funcB函数的一个引用。</span><span class="token keyword">print</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>state<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#a参数已经被内层函数funcB记住了</span><span class="token number">20</span>state<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token number">30</span></code></pre></li><li><p>装饰器：</p><p>函数名是函数引用；函数名后加一对小括号是对函数的调用</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">report</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    func<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>装饰器作用：拿函数当参数，做闭包，把函数参数传入嵌套函数内部</p><p><a href=""><strong>在不修改原来函数代码的前提下增加功能</strong></a></p><p>语法：@嵌套函数名字            （即附加的功能函数）</p><p> 比如myfunc = timemaster(mufunc)  等价于 @timemaster</p><p>然后正常调用函数即可</p><p><a href="">语法糖下边是所参入函数的声明,所以定义的函数被装饰了</a></p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add1</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>            <span class="token keyword">return</span> x<span class="token operator">+</span>x        <span class="token keyword">return</span> inner    <span class="token keyword">return</span> add<span class="token keyword">def</span> <span class="token function">cube</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token operator">*</span>x    <span class="token keyword">return</span> inner<span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>x    <span class="token keyword">return</span> inner@add1<span class="token punctuation">(</span>msg <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">)</span>@cube@square<span class="token comment" spellcheck="true">#从下往上调用装饰器  2+2  4*4*4  64+64</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token comment" spellcheck="true">##语法糖之后就可以调用函数了 </span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>装饰器带参数实质是多添加一次调用，两层嵌套函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">logger</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">timemaster</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            func<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> innner    <span class="token keyword">return</span> timemaster@logger<span class="token punctuation">(</span>msg <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">)</span></code></pre><ul><li>lambda表达式：  <a href="">匿名函数</a>(不需要考虑给<a href="">过于简单</a>的函数起名了)  一行流代码</li></ul><p>​    语法： lambda arg1， arg2, arg3, ……argN : expression</p><pre class=" language-python"><code class="language-python">squareY <span class="token operator">=</span> <span class="token keyword">lambda</span> y<span class="token punctuation">:</span> y<span class="token operator">*</span>ysquareY<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token number">9</span><span class="token comment" spellcheck="true">#squareY是函数的调用</span></code></pre><p>​    lambda是一个表达式，可以放在常规def函数放不到的地方，比如列表里</p><pre class=" language-python"><code class="language-python">y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span>x<span class="token operator">*</span>x <span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">4</span>mapped <span class="token operator">=</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> ord<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'hello wukun!'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#map函数第一个参数是函数的调用 第二个参数是调用函数内的参数</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>mapped<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">118</span><span class="token punctuation">,</span> <span class="token number">118</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">129</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">117</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">]</span>filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>filter<span class="token punctuation">(</span>function<span class="token punctuation">,</span>iterable<span class="token punctuation">)</span> function <span class="token operator">-</span><span class="token operator">></span> 判断条件iterable <span class="token operator">-</span><span class="token operator">></span> 可迭代对象</code></pre><ul><li><p>生成器</p><p>让函数在退出之后还能保留原来状态：闭包或者全局变量</p><p>还可以用生成器（相当于制作机器，每调用一次生成一个数据，而并且保留状态）：用yield替代return</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> counter <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span><span class="token number">0</span>     <span class="token keyword">while</span> i <span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">:</span>              <span class="token keyword">yield</span> i              i <span class="token operator">+=</span><span class="token number">1</span> <span class="token comment" spellcheck="true">##再次调用counter生成器时，会从 i+=1 开始</span></code></pre></li></ul><p>​      特殊的迭代器，不走回头路，还可以支持next（）函数，不支持下标索引。</p><p>​      生成器表达式：</p><p>​        </p><pre class=" language-python"><code class="language-python">t <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> t<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token number">0</span><span class="token number">1</span><span class="token number">4</span><span class="token number">9</span><span class="token number">16</span><span class="token number">25</span><span class="token number">36</span><span class="token number">49</span><span class="token number">64</span><span class="token number">81</span></code></pre><ul><li><p>递归</p><p>迭代是while循环类似，而递归是循环调用函数本身。汉诺塔的应用是递归的最佳例子：找到关键循环和形参实参的区别调用。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>                   <span class="token comment" spellcheck="true">#定义汉诺塔函数,参数n是圆盘数，A、B、C是3根柱</span>   <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                           <span class="token comment" spellcheck="true">#判断圆盘数，如果等于1，递归条件</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token string">'-->'</span><span class="token punctuation">,</span>C<span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 直接将A柱上的圆盘移动到C柱上</span>   <span class="token keyword">else</span><span class="token punctuation">:</span>                              <span class="token comment" spellcheck="true">#否则，进行递归移动</span>      hanoi<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>A<span class="token punctuation">,</span>C<span class="token punctuation">,</span>B<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#递归将A柱最上方的n-1个盘子落在B柱</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token string">'-->'</span><span class="token punctuation">,</span>C<span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出将A柱上的圆盘移动到C柱上,也就是将A柱的最小面盘子落在C柱</span>      hanoi<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>B<span class="token punctuation">,</span>A<span class="token punctuation">,</span>C<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">#递归将B柱上的n-1个盘子，落在C柱</span>hanoi<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#调用函数</span></code></pre></li><li><p>函数文档说明：</p></li><li><p>高阶函数：一个函数接收另一个函数，将函数作为参数使用；python库中有许多集成的高阶函数模块：functools ，可以自己调用</p><p>例如：functools.reduce(a,b)</p></li></ul><ul><li><p>永久储存：把代码储存在硬盘中</p><p>1、操作文件</p><p>使用f = open（）；其中第一个参数：‘文件路径’，第二个参数：‘操作类型: w.  r   ’,返回文件对象</p><p><a href="">w操作类型是先把文件清空，再写入内容</a></p><p>文件指针类似于文件内存位置：f.read()</p><p>2、处理路径</p><p>pathlib模块  from pathlib import Path  </p><p>p = Path(文件路径名)</p><p>避免字符串重复处理转义 <a href="/">/</a> 的问题</p><p>.. 为上一级路径， ./ 为当前路径  .为当前路径</p><p>3、with语句和上下文管理器</p><p>不需要手动关闭文件 ,<a href="">确保资源的释放</a>：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#常规操作文件流程</span>f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'fichc.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'I  love fichc.com'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#上下文管理器</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'fishc.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'I love fishc.com'</span><span class="token punctuation">)</span></code></pre><p>pickle模块：将python对象序列化（将python对象（变量，列表，字典）转换成二进制字节流）</p><p>以pkl后缀，</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'ii.pkl'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">##wb二进制写入模式</span>    pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 存入</span>    x<span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token comment" spellcheck="true">##读取</span></code></pre><blockquote><p>print函数的作用是打印输出内容，它的sep和end参数可以让我们的打印更具有个性化。</p><p>seq：用来间隔多个对象，默认值是一个空格。也可以输入特定的值（符号、数字、中文都可）来间隔内容。<br>end：用来设定以什么结尾，默认值是换行符”\n”。也可以输入其他值来结尾</p></blockquote></li><li><p>异常处理</p><p>捕捉异常使用try/except语句</p><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token keyword">except</span> ZeroDivisionError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'没有出错！'</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'出没出错都要执行这条语句'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##检测多个类型错误，用tuple</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>    <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'fishc'</span><span class="token keyword">except</span> <span class="token punctuation">(</span>ZeroDivisionError<span class="token punctuation">,</span>TypeError <span class="token punctuation">,</span> ValueError<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">##如果是这些类型错误则执行以下语句</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'出错了！！'</span><span class="token punctuation">)</span></code></pre><p>自己主动<a href="">抛出异常</a>（Python中有的异常类型）：</p><p>1、raise A异常和raise A异常 from B异常</p><p><code>raise ValueError('这是一个数值错误！,由除以0的错误产生的')</code> <code>from ZeroDivisionError</code></p><p>利用raise可以用出goto效果：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> true<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'跳过'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'跳过'</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'raise抛出异常后直接跳到这条语句了'</span><span class="token punctuation">)</span></code></pre><p>2、assert  只会产生AssertionError, 类似一个断点，便于调试</p><p><code>a = 1</code></p><p><code>assert a ==1</code></p><p><code>assert a !=1</code></p></li></ul><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程三大基本特征：封装、继承、多态</p><p>面向对象也是一种代码封装的方法。</p><p>$对象 = 属性（特征）+方法（能做的事）$</p><blockquote><p>类是“一种摸具”，可以批量生产对象。例如人类是类，一个特定的人是对象。</p></blockquote><ul><li><p>封装：创建对象之前，通过类将相关属性和方法打包到一起，然后通过类生成相应的对象： <code>c = Turtle()</code></p><p>类中方法默认的第一个参数‘self’是实例化对象本身，目的是让python清楚是哪个实例对象在调用方法</p></li><li><p>继承：</p><p><code>c = B(A)</code>, 类B继承类A，父类已有属性和方法重在子类中写会<a href="">覆盖</a></p><p>多重继承： <code>class C(A,B)</code>,实例化后属性和方法会先继承A类的，从左至右顺序(<a href="">MRO</a>,方法解析顺序)。</p><p>组合：将多个实例化对象放在类中，比如一个花园摸具中应该有狗，猫，鱼等。</p><blockquote><p>tip: python默认所有类继承于object</p></blockquote></li><li><p>绑定</p><p>self起到的作用是：将实例对象与类的方法绑定</p><blockquote><p>在实例中，除了类的方法可以共享外，实例的属性可以是自己的</p></blockquote><p>通过类中的方法设置属于对象自己的属性，可以通过绑定：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">set_value</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> value    </code></pre><p>这段代码其实相当于实例化后<code>a.x = value</code></p><p>实例化对象是没有属于自己的属性的，只会从生成它的类中去查询，但当自己实例化属性后就拥有了，</p><p>类的属性是所有对象共享的，类中的属性最好不要随意更改，牵一发而动全身</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    x<span class="token operator">=</span><span class="token number">1</span>a <span class="token operator">=</span>A<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">{</span><span class="token punctuation">}</span>a<span class="token punctuation">.</span>x <span class="token operator">=</span><span class="token number">90</span>a<span class="token punctuation">.</span>x<span class="token number">90</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span></code></pre><p>tip: 类和对象的属性通过<a href="">字典</a>,对象中的<code>__dict__</code>属性保存。</p><p><code>pass</code>为占位语句，最小的类中只有pass，空类生成的实例可以当作字典</p></li><li><p>构造函数：在类中定义构造函数以实现实例个性化</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x        self<span class="token punctuation">.</span>y <span class="token operator">=</span> y   <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>x <span class="token operator">+</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##相当于实例化时可以传参数了</span></code></pre><p>钻石（菱形）继承问题：若自己两个父类的父类是同一个，那么将调用”爷“类两次</p><p>通过<code>super（）</code>函数解决查找父类方法重复的问题，<code>super().__init__()</code></p></li><li><p>Mixin:</p><p>它是一种<a href="">设计模式</a>（利用编程语言已有的特性针对面对对象开发过程中反复出现的问题而设计出来的解决方案）</p><p><a href="">super()函数严重依赖MRO顺序</a>，也会寻找同等继承关系的类，再去寻找上一级父类</p><p>可以通过多继承添加功能，在添加功能时（mixin）时也可以使用super（）函数去寻找同等继承关系类的方法</p></li><li><p>多态</p><p>是指一个运算符，函数或者对象在不同的场景下有不同的作用效果，比如<code>3+3</code>与<code>'fishc'+'fishc'</code>，两个<code>+</code>号的作用不同作用，又如<code>len()</code></p><p>多个子类继承同一个父类，但又重写了构造函数或者方法，这就是多态的体现。</p><p>当函数接收不同的参数（继承一个父类，但是重写方法或者构造函数了）有不同的输出，这就具有多态性了</p></li><li><p>私有变量</p><p>通过某种手段使对象中的属性和方法不被外部访问</p><p>在python中是在变量前加两个下划线作为“私有变量”:<code>__x</code>，不能直接访问和修改，只能通过接口（内部定义函数来修改），还可以通过c._C__x</p><blockquote><p>在python中私有变量其实是通过改名实现的，<code>__x</code>变为了<code>_C__x</code></p></blockquote><p>私有方法也是如此操作，私有变量，私有方法名字改编是在类实例化对象的时候。</p><p>单个下横线开头的变量 <code>_x</code>通常是仅供内部使用的变量，不要随意访问和试图修改</p><p>实例化对象可以<a href="">动态添加属性</a>，是因为这个字典的机制，可以通过<code>c.__dict__['x']= 666</code>添加属性</p><p>字典除了浪费空间外，其他都是优点，针对这一缺陷，python出了类属性<code>__slots__ = [‘x’,‘y’]</code>,这样限制了实例化对象只能拥有x,y两个属性，构造函数个性化多参数也不行，限制死了。</p><p>tip:继承自父类的<code>__slots__</code>不会在子类生效 </p></li><li><p>魔法方法：实现对象的个性化定制，作用是拦截，重写运算符</p><p>例如<code>__init__()</code>在对象实例化时就自动调用从而实现了对象的个性化定制</p><p>1<code>__new()__(cls[])</code>,在<code>__init__(self)</code>之前，是第一个调用的魔法方法，用于创建对象，返回实例化对象传递给<code>__init__()</code></p><p>2.<code>__del__(self)</code>,在对象没有被引用后启动，例如:</p><pre class=" language-python"><code class="language-python">c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">del</span> c<span class="token comment" spellcheck="true">##此时会执行__del__()</span>c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> c<span class="token keyword">del</span> c<span class="token comment" spellcheck="true">##此时d还在引用c对象，所以不会执行__del__()</span></code></pre><p>3.运算相关的魔法方法</p><ul><li><p>运算魔法方法：例如<code>__add__(self,other)</code>,通过重写覆盖，使得两个字符串之间相加结果不是拼接，而是返回字符个数之和。</p><p><code>s1+s2</code>实际是<code>s1.add(s2)</code></p></li><li><p>反运算魔法方法：<code>__radd__(self,other)</code><a href="">,两个基于不同类的对象</a>进行相加运算时，若左边对象的add魔法方法返回NotImplemented关键字，则会去寻找右边对象的<code>__radd__(self,other)</code>方法。</p></li></ul></li></ul><ul><li><p>赋值运算魔法方法：例如<code>__iadd__(self,other)</code>实现的就是+=运算符,若增强运算符左侧的对象没有实现相应的魔法方法，则python就会退而求其次，寻找<code>__add__(self,other)</code>、<code>__radd__(self,other)</code>来实现</p><p>内置函数魔法方法：例如<code>__int__(self)</code></p></li><li><p>位运算魔法方法：按位与<code>&amp;</code>，按位或<code>|</code>,按位非<code>~</code>，按位异或^,左移&lt;&lt;,右移&gt;&gt;</p></li><li><p><code>__index__(self)</code>,在对象作为索引值时会发生拦截，触发。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__index__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'触发'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">3</span>c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token string">'fishc'</span>s<span class="token punctuation">[</span>c<span class="token punctuation">]</span>h</code></pre></li></ul><p>  4.属性访问相关的魔法方法 </p><p>  <code>hasattr(c,'name')</code>判断c对象中是否有name这个属性</p><p>  <code>getattr(c,'name')</code>得到对象属性的值，对应魔法方法为<code>__getattribute__(self,attrname)</code>,<code>__getattr__(self,attrname)</code>对应是当寻找一个不存在的属性时触发</p><p>  <code>setattr(c,'age',10)</code>设置对象属性的值，对应魔法方法为<code>__setattribute__(self,attrname,value)</code></p><blockquote><p>进行魔法方法<code>_setattribute__(self,attrname,value)</code>重写时若有再次赋值<code>self.name = name</code>,则会无限递归属性赋值魔法方法，解决办法：使用对象属性<code>self.__dict__[attrname] = value</code>避免。</p><p>同理,重写<code>__delattr__(name)</code>时，使用<code>del self.__dict__[name]</code>避免递归</p></blockquote><p>  <code>delattr(c,'name')</code>删除对象属性</p><p>  5.索引、切片、迭代协议</p><p>  当对象被索引时用到的魔法方法为<code>__getitem__(self,index)</code>，for循环函数也会索引对象</p><p>  切片函数<code>slice(none:none:4)</code>,开头和结尾为默认，每间隔4提取一个字符</p><p>  迭代器中有<code>__iter__(self)</code>和<code>__next__(self)</code>魔法方法，实现的next()函数是<a href="">真正实现迭代</a>操作的</p><blockquote><p>如果一个对象有<code>__iter__(self)</code>则为可迭代对象，如果可迭代对象有<code>__next__(self)</code>则为可迭代器</p><p>list是个可迭代对象，没有next魔法方法，所以不是迭代器</p></blockquote><p>  6.代偿</p><p>  <code>__contains__(self,item)</code>为in 和not in 运算符的魔法方法，用于实现成员的检测</p><p>  如果使用了in 和not in 运算符，而对象中没有<code>__contains__(self,item)</code>，则会使用<code>__iter__(self)</code>和<code>__next__(self)</code><a href="">代偿</a>，如果再没有，则会寻找<code>__getitem__(self,index)</code></p><blockquote><p>不希望哪个魔法生效的话，直接赋值为None，例如<code>__contains__ = None</code>,则会产生代偿时限，不会再去继续寻找代偿的魔法方法</p></blockquote><p>  7.</p><p>  <code>__call__(self,[,args])</code>对应当是实例化对象作为函数使用时调用的魔法方法。</p><p>  <code>eval()</code>函数作用是将参数去引号后执行,<code>repr()</code>是对参数加引号</p><p>  对于<code>__str__(self)</code>和<code>__repr__(self)</code>  repr魔法方法适用范围更广。print()调用的是<code>__str__(self)</code>魔法方法，直接打印调用的是<code>__repr__(self)</code> </p><p>  8.property函数</p><p>  与str()函数一样作为python内置函数，返回property属性对象</p><p>  作用是:负责把一个方法当作属性进行使用(<a href="">对应属性操作中的访问,修改和删除</a>，拦截原来属性的访问，修改和删除操作),这样做可以简化代码</p><p>  定义property属性有两种方式:装饰器方式和类属性方式   x = property(属性的获取,设置,删除)</p><ul><li><p>类方法和静态方法</p><p>类方法和静态方法都属于类，不用实例化对象都可以使用。</p><p>类方法：专门用于绑定类的方法，用装饰器@classmethod实现，比如可以了解这个类实例化了多少对象</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">:</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">funA</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span>：        <span class="token keyword">print</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span></code></pre><p>静态方法：可以放在类中的方法，用@staticmethod实现，可以不用绑定参数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">:</span>    @stasicmethod    <span class="token keyword">def</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>描述符</p><p>定义：只要实现了属性的三大操作方法（访问，修改和删除）的类就叫做描述符，就是函数当属性使用。</p><p>访问：<code>__get__(self,instance,owner)</code></p><p>修改：<code>__set__(self,instance,value)</code></p><p>删除：<code>__delete__(self,instance)</code></p><blockquote><p>其中self对应的是描述符这个类的实例化对象，instance对应的是被描述符拦截的<a href="">属性</a>所在的类的实例化对象，owner对应的是被描述符拦截的属性所在的类</p></blockquote><p>描述符只能作用在类属性，不能作用在实例化对象的属性,如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>instance<span class="token punctuation">,</span>owner<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"get_"</span><span class="token punctuation">)</span>                <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x  <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>非数据描述符：实现<code>__get___</code>,数据描述符：实现<code>__set__,__delete__</code>之一</p><p>当发生属性访问时，<a href="">拦截顺序</a>是数据描述符，实例对象属性，非数据描述符，类属性，其中魔法方法<code>__getattribute__(self,name)</code>优先级最高</p><p>描述符在python3.6中最新添加了一个魔法方法：<code>__set_name__(self,owner,name)</code>,可以间接作用在实例化对象的属性</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__set_name__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>owner<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>instance<span class="token punctuation">,</span>owner<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'get_'</span><span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__set__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>instance<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>__dict__<span class="token punctuation">[</span>self<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> value        <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>    c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>xget_c<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">250</span>setc<span class="token punctuation">.</span>__dict__<span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">250</span><span class="token punctuation">}</span>c<span class="token punctuation">.</span>xget_</code></pre></li><li><p>函数，方法，静态方法，类方法</p><p>在python中函数就是一个非数据描述符</p></li><li><p>类装饰器</p><p>作用就是在类实例化对象之前进行拦截</p></li><li><p>type（）函数和<code>__init__subclass__</code></p><p>type（）查看对象的类型，所定义的类的类型起源与type类型，类是由type创造而来的。</p><p><code>__init__subclass__</code>魔法方法便于父类管理子类，当继承父类时会拦截覆盖相关的属性</p></li><li><p>元类及其应用</p><p>元类是创造类的模板，所有的元类都继承于type，元类就是在type和类之间架上了一座桥梁。</p><p>元类中的<code>__new__</code>魔法方法是在定义完继承于该元类时触发的，而定义的类的<code>__new__</code>方法是在实例化对象时才触发。</p><p>应用一：给所有定义的类添加属性</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>mcls<span class="token punctuation">,</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>        attrs<span class="token punctuation">[</span><span class="token string">'father'</span><span class="token punctuation">]</span> <span class="token operator">=</span> fishc        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>mcls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>fatherfishcd<span class="token punctuation">.</span>fatherfishc      </code></pre><p>应用二：对类名的规范做限制</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> name<span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"类名字的首个字母必须大写！"</span><span class="token punctuation">)</span>        type<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span>        <span class="token keyword">class</span> <span class="token class-name">myclass</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;pyshell#12>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token keyword">class</span> <span class="token class-name">myclass</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;pyshell#10>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __init__    <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"类名字的首个字母必须大写！"</span><span class="token punctuation">)</span>TypeError<span class="token punctuation">:</span> 类名字的首个字母必须大写！</code></pre><p>应用三：修改对象的属性值</p><blockquote><p>当类实例化时都会去调用call魔法方法，相当于引用函数c = C()</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_args <span class="token operator">=</span> <span class="token punctuation">[</span>each<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> each <span class="token keyword">in</span> args <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>each <span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__call__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>new_args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> xc <span class="token operator">=</span>C<span class="token punctuation">(</span><span class="token string">"fishc"</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>x<span class="token string">'FISHC'</span></code></pre><p>应用四：限制对象实例化时传参的方式</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> args<span class="token punctuation">:</span>            <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"仅支持关键字参数传参"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__call__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>new_args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span></code></pre><p>应用五：干预类的实例化</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"不支持实例化对象"</span><span class="token punctuation">)</span></code></pre><p>应用六：只允许实例化一个对象</p></li><li><p>抽象基类</p><p>比如：“水果类”</p><p>特点：不能被直接实例化，只能继承使用；<a href="">子类必须实现抽象基类定义的抽象方法</a>（即重新定义覆盖抽象方法），否则不能被实例化。</p><p>可以导入abc模块来对一个类作为抽象基类。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> abc <span class="token keyword">import</span> ABCMeta<span class="token punctuation">,</span>abstractmethod<span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> ABCMeta<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    @abstractmethod    <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span> </code></pre></li><li><p>写代码的精髓：不要重复造轮子。</p></li></ul><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>python中最高级的代码的打包手段，使得一个或者多个源代码文件可以被其他程序重复使用。</p><ul><li><p>the latest的名字冲突会覆盖</p></li><li><p>模块在导入过程中会从头至尾执行模块中的语句。<code>if '__name__' == '__main__'</code>语句就是用来判断该文件是否为主文件来执行。若该文件被作为模块引用，则<code>__name__</code>变为了文件名</p></li><li><p>包</p><p>支持把源文件分类储存到不同的文件夹中。用<code>.</code>号将包与模块分开，例如<code>Test.test1</code></p><p>可以编写包中的<code>__init__.py</code>源文件(相当于<a href="">构造文件</a>)对包初始化进行特定的操作。</p><p>源文件中的<code>__all__</code>属性可以限制<a href="">from…. import  *</a>语句所引用的内容</p><blockquote><p>对于包来说，没有定义<code>__all__</code>属性，则from…. import  *语句将不导入包中的任何模块</p><p>对于模块来说，没有定义<code>__all__</code>属性，则from…. import  *语句将不导入模块中的任何东西</p></blockquote></li><li><p>与全世界分享代码</p><p>将程序发布到Pypi（python package index），python包的索引仓库。pip工具在命令行窗口可以下载Pypi的第三方模块包并安装。</p></li></ul><p>==过完基础，撒花！！！==</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小白教小白之博客搭建~</title>
      <link href="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/"/>
      <url>/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>​        跟着B站评论区大佬的博客学了两三天，自己也是终于把个人博客的大致框架搭了起来，踩过不少坑。然后想着自己可以在第一篇博客上把搭建的过程分享出来。当然哈，自己是个纯小白，八分主观，两分运气，如有不足之处请见谅。</p><h2 id="二、博客环境搭建"><a href="#二、博客环境搭建" class="headerlink" title="二、博客环境搭建"></a>二、博客环境搭建</h2><p>​        有挺多用来写博客的框架，比如WordPress、Jekyll 、Hugo、Django 、Hexo ，我选择的是Hexo，其是基于node.js制作的一个博客工具，赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，快速、简洁且高效，是搭建博客的首选框架。对于服务器的选择，Hexo+Github是上手的最佳方式。</p><h3 id="2-1-下载Node-js与Git"><a href="#2-1-下载Node-js与Git" class="headerlink" title="2.1.下载Node.js与Git"></a>2.1.下载Node.js与Git</h3><p>​        首先去Node.js与Git的官网，根据自己的电脑系统选择对应的版本进行下载和安装。安装位置最好选择在C盘以外。</p><h3 id="2-2Node-js的安装"><a href="#2-2Node-js的安装" class="headerlink" title="2.2Node.js的安装"></a>2.2Node.js的安装</h3><p>​    官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><ul><li><p>node.js默认安装即可，终端输入node -v 查看是否安装成功。</p><blockquote><p> <strong>注意： 如果执行 node -v 报错的话，那么手动将 Node.js 的安装路径添加到环境变量中</strong>。</p><p> <strong>添加环境变量参考：</strong><a href="https://www.cnblogs.com/ldq678/p/13287924.html">https://www.cnblogs.com/ldq678/p/13287924.html</a></p></blockquote></li><li><p>cnpm工具安装(npm国内下载速度不太行，选用淘宝镜像源加速)</p><p>终端输入<strong>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></strong>j进行安装。</p><p>终端输入cnpm -v查看是否安装成功。</p></li></ul><h3 id="2-3Git的安装"><a href="#2-3Git的安装" class="headerlink" title="2.3Git的安装"></a>2.3Git的安装</h3><p>​    官网：<a href="https://nodejs.org/en/">https://git-for-windows.github.io/</a></p><ul><li>默认安装即可，终端输入git -v 查看是否安装成功</li></ul><h3 id="2-4Hexo的安装"><a href="#2-4Hexo的安装" class="headerlink" title="2.4Hexo的安装"></a>2.4Hexo的安装</h3><p>​    前面Git和Node.js安装好后，就可以安装hexo了。</p><ul><li>安装指令：<strong>cnpm install -g hexo-cli</strong><br>依旧用hexo -v查看一下版本至此就全部安装完了。</li></ul><h2 id="三、博客推送GitHub"><a href="#三、博客推送GitHub" class="headerlink" title="三、博客推送GitHub"></a>三、博客推送GitHub</h2><p>​        自己将博客编写完成后，需要借助GitHub的服务器发布到网上。首先是github账户的注册，应该较为简单。</p><h3 id="3-1Git-的配置"><a href="#3-1Git-的配置" class="headerlink" title="3.1Git 的配置"></a>3.1Git 的配置</h3><p>​        在桌面点击鼠标右键，点击 Git Bash Here，然后分别输入下面的两个命令，并回车。</p><pre class=" language-none"><code class="language-none">git config --global user.name "此处填写你注册时的用户名"git config --global user.email "此处填写你注册时的邮箱"# 一般只要不报错，可以跳过下面寻找.gitconfig文件</code></pre><h3 id="3-2Github-的配置"><a href="#3-2Github-的配置" class="headerlink" title="3.2Github 的配置"></a>3.2Github 的配置</h3><p><strong>创建：</strong></p><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><p><strong>注意：</strong></p><ul><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：username.github.io，其中username是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</li><li>创建页面如下：</li></ul><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/1.jpg" alt="img"></p><ul><li><p><strong>配置SSH 免密登录</strong></p><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><p>**简单的来说就是给予你当前电脑访问你GitHub 仓库的权限 **</p><p><strong>操作步骤：</strong></p></li></ul><ol><li><p>在 git bash here 中创建一个ssh密钥</p><p>指令：<code>cd ~/.ssh</code></p><p>如果本地有的话，它会自动进入到了ssh目录下；</p><p> 若没有则创建： <code>ssh-keygen -t rsa -C "邮箱"</code> 此处邮箱填写自己的邮箱</p><p>然后enter三连</p><p>生成两个文件： id_rsa id_rsa.pub 存放在 C:\Users\admin.ssh 文件夹下</p><p><strong>注意：pub文件放置的，就是我们的公开的ssh码，也是给管理员这个ssh，让他来添加</strong></p></li><li><p>在GitHub 或者 Gitee 上添加 SSH key</p></li></ol><p>​        Title：随意填写</p><p>​        Key：将本地的id_rsa.pub文件用记事本打开，复制全部内容粘贴到GitHub 仓库的SSH Keys 位置</p><p>​        如下图所示：</p><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/2.jpg" alt="img"></p><p><strong>至此，全部环境均已搭建好，接下来就是博客的编写和上传了</strong></p><h3 id="3-3博客的初始化"><a href="#3-3博客的初始化" class="headerlink" title="3.3博客的初始化"></a>3.3博客的初始化</h3><ol><li><p>在电脑的某个地方新建一个名为HexoData的文件夹（名字可以随便取），这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p></li><li><p>在该文件夹下右键打开 Git Bash</p><p>并依次执行以下命令</p><p><code>hexo init</code> 初始化命令，hexo会自动下载一些文件到这个目录，包括node_modules等</p><p><code>hexo g</code> 生成命令</p><p><code>hexo s</code> 启动服务</p><p><strong>说明：</strong><code>hexo s</code> 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，说明博客初始化以及成功！</p><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/4.jpeg" alt="img"></p><p>很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，</p><p>因为4000这个端口太常见了， 只需要关闭4000端口并重新启动即可</p><p><strong>到此博客的初始化便完成了，此时你可以本地开启服务并访问，下一步便是推送到GitHub 上！</strong></p></li></ol><h3 id="3-4推送至Github"><a href="#3-4推送至Github" class="headerlink" title="3.4推送至Github"></a>3.4推送至Github</h3><ul><li><p>第一步：在自己定义的博客目录下安装 hexo-deployer-git 插件 （git bash here 处安装）</p><p>命令：<code>npm install hexo-deployer-git --save</code></p><p>说明：必须安装，否则执行hexo d 的话会报错</p><p><strong>新建自己定义的博客目录完成后，指定文件夹目录下有：</strong></p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul></li><li><p>第二步：编辑博客目录下的 _config.yml 文件, 在文件末尾修改配置文件：</p><pre class=" language-none"><code class="language-none">deploy:  type: git  repo: github上对应仓库的ssh 链接      //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git              branch: main</code></pre><p><strong>说明：</strong>仓库的ssh链接如下</p><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/3.jpg" alt="img"></p><p><strong>切记：分支branch切记修改为 main，之前github的默认主分支为master，现已经改为main</strong> ！</p></li><li><p>第三步：在博客目录下, 将本地 blog 推送到 github仓库</p><p>输入命令：<code>hexo d</code></p><p>也可能需要输入 username &amp; pwd</p><p>推送成功后, 在浏览器中输入对应域名, 即可访问</p><p><strong>至此，你便初步搭建好了一个属于自己的博客！（本地服务不用启动依然可以访问）</strong></p></li><li><p><strong>hexo 框架常用的指令：</strong></p><table><thead><tr><th align="left">指令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>hexo clean &amp;&amp; hexo g</code></td><td align="left">清除本地项目并重新生成 （重新部署时使用）</td></tr><tr><td align="left"><code>hexo g</code></td><td align="left">重新生成</td></tr><tr><td align="left"><code>Hexo s</code></td><td align="left">开启本地预览</td></tr><tr><td align="left"><code>Hexo d</code></td><td align="left">推送到github</td></tr></tbody></table></li></ul><h2 id="四、Hexo-博客的美化"><a href="#四、Hexo-博客的美化" class="headerlink" title="四、Hexo 博客的美化"></a>四、Hexo 博客的美化</h2><p>​        根据自己的特定需要网上搜寻教程即可。</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ol><li><p>theme-matery 主题官方使用说明 <a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li><li><p><a href="https://laughingtiger.gitee.io/2021/11/29/ru-he-kuai-su-da-jian-shu-yu-zi-ji-de-bo-ke/">https://laughingtiger.gitee.io/2021/11/29/ru-he-kuai-su-da-jian-shu-yu-zi-ji-de-bo-ke/</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=df70199ed9e748e3043b11859e7a6050">https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=df70199ed9e748e3043b11859e7a6050</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
