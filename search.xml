<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++巩固</title>
      <link href="/2023/08/01/c-gong-gu/"/>
      <url>/2023/08/01/c-gong-gu/</url>
      
        <content type="html"><![CDATA[<h1 id="C-巩固"><a href="#C-巩固" class="headerlink" title="C++巩固"></a>C++巩固</h1><p>B站黑马程序员</p><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h4 id="1、hello-world"><a href="#1、hello-world" class="headerlink" title="1、hello world"></a>1、hello world</h4><h5 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h5><p>适用于大多数的C++程序：</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;int main(){        system("pause");    return 0;}</code></pre><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p><code>//单行注释</code></p><p><code>/*多行注释*/</code></p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>给一段指定的内存空间命名，便于操作</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>使数据不可更改</p><p>定义方式：1、#define宏定义   2、const修饰定义的变量</p><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>关键字是C++中预先保留的变量名字（标识符）</p><p>![img](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center-169090661184512.png)</p><h5 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h5><ul><li><p>标识符不能是关键字</p></li><li><p>标识符只能由字母、数字、下划线组成</p></li><li><p>第一个字符必须为字母或者下划线</p></li><li><p>标识符中字母区分大小写</p><p>tip：命名最好是见名知意，提高代码可读性</p></li></ul><h4 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h4><p>C++规定在创建一个变量或者常量的时候，必须要指定出相应的数据类型，否则无法给该变量分配内存空间。</p><p>意义：给变量分配<a href>合适</a>的变量空间</p><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p>表示整数的变量，占用空间中其中一位为符号位，0为正数，1为负数</p><p>![img](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center-16908030271203.png)</p><h5 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h5><p><strong>作用</strong>：统计数据类型所占空间的大小</p><p>语法：<code>sizeof(数据类型/变量);</code></p><h5 id="浮点型（实型）"><a href="#浮点型（实型）" class="headerlink" title="浮点型（实型）"></a>浮点型（实型）</h5><p><strong>作用</strong>：用于表示小数。浮点型分为两种-单精度float-双精度double</p><p>![img](E:\My Blog\Blog\source_posts\C++巩固.assets\20210610203143466-16955482143562.png)</p><blockquote><p>单精度代码格式最好为: float f1 = 3.14f</p><p>数字后不加f的话,编译器会默认把一个小数当做双精度,然后再把双精度转为单精度,多一次转换的时间.</p><p>浮点型默认输出显示只为6位有效数字,想要输出显示更多位,则需要另外配置</p></blockquote><h5 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h5><p><strong>作用</strong>：字符型变量用于显示单个字符</p><ul><li>C和C++中字符型变量只占1个字节</li><li>字符型变量并不是把所有的字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元中</li><li>查看ASCII码，使用<code>(int)</code>强制转换字符型变量即可,也可用ASCII码给字符型赋值  a–97  A–65</li></ul><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p><strong>作用</strong>：用于表示一些不能显示出来的ASCII字符</p><p>![img](E:\My Blog\Blog\source_posts\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center.png)</p><h5 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h5><p><strong>作用</strong>:用于表示一串字符串</p><ul><li><p>C语言：char str[ ] = “string”</p><p>C++ :   string str = “string”,不过要包含头文件<code>#include &lt;string&gt;</code></p></li></ul><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p><strong>作用</strong>:布尔类型数据代表真或假的值</p><ul><li>true——真（1）</li><li>false——假（0）</li></ul><p>bool类型占1个字节大小</p><h5 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h5><p><strong>作用</strong>：用于从键盘获取数据</p><p><strong>语法</strong>：cin&gt;&gt;变量</p><h4 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h4><p><strong>作用</strong>:用于代码的运算</p><p>![img](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center-16909055645883.png)</p><h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><p><strong>作用</strong>：用于处理四则运算</p><p>![img](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center-16909059336656.png)</p><blockquote><p>两个整数相除结果还是整数；</p><p>两个小数相除结果还是小数,两个小数不能取模运算；</p><p>两个数相除除数不可以为0，也做不了取模运算；</p><p>前置递增++a——先让a+1然后再进行<a href>表达式运算</a>；    </p><p>后置递增a++——先进行<a href>表达式运算</a>然后a再+1，递减同理。</p></blockquote><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p><strong>作用</strong>：用于将表达式的值赋给变量</p><p>![image-20230802001904427](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230802001904427-16955482143563.png)</p><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p><strong>作用</strong>：用于表达式的比较，并返回一个真值或假值</p><p>![image-20230802181654758](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230802181654758-16955482143564.png)</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p><strong>作用</strong>：用于根据表达式的值返回真值或假值</p><p>![image-20230802182356342](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230802182356342-16955482143565.png)</p><h4 id="4、程序流程结构"><a href="#4、程序流程结构" class="headerlink" title="4、程序流程结构"></a>4、程序流程结构</h4><p>C/C++支持最基本的三大基本程序运算结构:<strong>顺序结构、选择结构、循环结构。</strong></p><ul><li>顺序结构：程序按顺序执行，不发生跳转。</li><li>选择结构：依据条件是否满足,有选择的执行相应代码。</li><li>循环结构：依据条件是否满足，循环多次指定某段代码。</li></ul><h5 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h5><h6 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h6><p><strong>作用</strong>：执行满足条件的语句</p><ul><li><p>单行格式if语句 <code>if(条件){条件满足执行的语句}</code></p></li><li><p>多行格式if语句 <code>if(条件) { 条件满足执行的语句 } else { 条件不满足执行的语句 }</code></p></li><li><p>多条件if语句  <code>if(条件1) { 条件1满足执行的语句 } else if(条件2) { 条件2满足执行的语句 } ...... else {都不满足执行的语句 }</code></p></li><li><p>嵌套if语句  作用：实现更为精准的判断</p><p><code>if() { if() } else { }</code></p></li></ul><h6 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h6><p><strong>作用</strong>：通过三目运算符实现<a href>简单</a>的判断</p><p><strong>语法：</strong><code>表达式1？表达式2：表达式3</code></p><p><strong>解释：</strong></p><p>如果1为真，则结果为表达式2的值。</p><p>如果1为假，则结果为表达式3的值。</p><blockquote><p>C++中三目运算符返回的是变量，可以继续赋值</p><p>a &gt; b ? a : b = 100</p></blockquote><h6 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h6><p><strong>作用</strong>：执行多条件分支语句</p><p>语法：</p><pre class=" language-c++"><code class="language-c++">switch(表达式){        case 结果1：            执行语句;            break;//退出当前分支        ......        default：            执行语句;            break;}</code></pre><p>switch和if的区别：</p><ul><li>优点：结构清晰，执行效率快</li><li>缺点：在判断时候不能是区间，只能是<a href>整形</a>和<a href>字符型</a></li></ul><h5 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h5><h6 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h6><p><strong>作用</strong>:满足循环条件，执行循环语句</p><p><strong>语法</strong>:<code>while(循环条件){循环语句}</code></p><h6 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a>do-while循环语句</h6><p><strong>作用</strong>：先执行，后判断循环条件</p><p><strong>语法</strong>:</p><pre class=" language-c++"><code class="language-c++">do{        循环语句}while(循环条件)</code></pre><h6 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h6><p><strong>作用</strong>:满足循环条件，执行循环语句</p><p><strong>语法</strong>:<code>for(起始条件;条件表达式;末尾循环体){ 循环语句}</code></p><h6 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h6><p><strong>作用</strong>:在循环体中再嵌套一层循环，解决一些实际问题，外层循环一次，内层循环一周</p><h5 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h5><h6 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h6><p><strong>作用</strong>:用于跳出<a href>选择</a>结构或者<a href>循环</a>结构</p><p>break使用的时机：</p><ul><li>出现在switch语句中，作用是终止case并跳出swtich</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套语句中，跳出最近的内层循环语句</li></ul><h6 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h6><p>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，<a href>继续执行</a>下一次循环</p><h6 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h6><p><strong>作用</strong>:可以无条件跳转语句</p><p><strong>语法</strong>:</p><pre class=" language-c++"><code class="language-c++">goto Flag;......Flag:......</code></pre><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句的时候，会跳转到标记的位置。</p><blockquote><p>在程序中，不要频繁使用goto语句，以免造成程序流通混乱</p></blockquote><h4 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h4><p>所谓数组就是一个集合，里面存放了<a href>相同类型</a>的数据元素</p><p><strong>特点1</strong>：数组中的每个数据元素都是相同的数据类型</p><p><strong>特点2</strong>：数组放在一块<a href>连续的内存空间</a></p><p><strong>缺点</strong>：容量大小不可变，有内存溢出风险  </p><p><strong>与vector的区别</strong>：</p><p>![image-20230805000214983](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230805000214983-16955482143566.png)</p><h6 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h6><p>语法:</p><pre class=" language-c++"><code class="language-c++">数据类型 数组名[数组长度];数据类型 数组名[数组长度] = {值1，值2......};数据类型 数组名[] = {值1，值2......};;</code></pre><p>数组名：</p><ul><li>获取数组的首地址  <code>cout&lt;&lt;arr</code></li><li>计算所占内存大小  <code>sizeof(arr)</code>  <code>sizeof(arr[i])</code></li></ul><p>冒泡排序：</p><p><strong>作用</strong>:最常用的排序算法，对数组内元素进行排序，用嵌套循环实现</p><ol><li>比较相邻两个元素，如果第一个比第二个大就交换他们的位置</li><li>每一对相邻元素做同样的工作，整型完毕后，找到第一个最大值</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><h6 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h6><p>两个维度的数组</p><p>定义:</p><pre class=" language-c++"><code class="language-c++">数据类型 数组名[行][列];数据类型 数组名[行][列] = {{数据1，数据2}，{数据3，数据4}};//这种最为直观数据类型 数组名[行][列] = {数据1，数据2，数据3，数据4};数据类型 数组名[][列] = {数据1，数据2，数据3，数据4};//不能只写行数</code></pre><p>数组名：</p><ul><li><p>查看二维数组所占内存空间</p><ul><li>整个数组的空间：<code>sizeof(arr)</code></li><li>一行：<code>sizeof(arr[0])</code></li><li>每一个数据：<code>sizeof(arr{0}[0])</code></li></ul></li><li><p>获取二维数组首地址和每行的首地址</p><p>具体的元素地址需要取地址符<code>(int) &amp;arr[0][2]</code></p></li></ul><h4 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><strong>作用</strong>:将一段经常使用的代码封装起来，减少重复代码。</p><p>​        一个较大的程序，一般分为若干个程序块，每个<a href>模块</a>实现特定的功能。</p><h5 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h5><p>五要素：返回值类型，函数名 ，参数，函数体语句，return表达式</p><h5 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h5><p><strong>语法</strong>:自定义的函数名(参数)</p><h5 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h5><ul><li>就是函数调用时将参数值传给形参</li><li>值传递时，形参改变，实参不改变</li></ul><h5 id="函数的常见样式"><a href="#函数的常见样式" class="headerlink" title="函数的常见样式"></a>函数的常见样式</h5><p>无参无返、有参无返、无参有返、有参有返</p><h5 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h5><p><strong>作用</strong>：告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>​         函数定义在main函数前可以不用定义，在main函数后必须要定义，不然编译器找不到相关函数进行调用。</p><p>​         函数的声明可以有很多次，定义只能有一次。</p><h5 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h5><p><strong>作用</strong>:让代码结构更加清晰</p><ul><li><p><a href>函数声名在.h头文件，函数的定义在.c源文件</a></p></li><li><p>源文件中<code>#include "自定义.h"</code>，使头文件和源文件关联</p></li><li><p>其他文件中包含自定义的头文件，即可使用自定义的函数</p></li></ul><blockquote><p>和Python中的模块和包有区别！</p></blockquote><h4 id="7、指针"><a href="#7、指针" class="headerlink" title="7、指针"></a>7、指针</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>指针的作用:可以通过指针<a href>间接访问</a>内存；指针是数据类型为地址的变量</p><ul><li>内存编号是从0开始记录的，一般用16进制数字标识</li><li>可以利用指针变量保存地址</li></ul><h5 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h5><p><strong>指针定义</strong>：数据类型+变量名  <code>int *p</code>    <code>p=&amp;a</code></p><p>指针前加*号，表示<a href>解引用</a>，找到指针指向的内存中的数据</p><h5 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h5><p>32位的系统占用4个字节；64位系统占用8个字节。</p><h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><p>指针变量指向内存中编号为0的空间</p><p><strong>作用</strong>:初始化指针变量</p><p><strong>注意</strong>:空指针指向的内存空间是不可以访问的，<a href>0-255是系统占用的</a>，不可访问</p><p>语法：<code>int* p = NULL;</code></p><h5 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h5><p>指针变量指向非法的内存空间，但是用户没有权限导致程序崩溃。</p><h5 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h5><p>3种情况：</p><ul><li><p>const修饰指针—常量指针</p><p>const修饰的是指针，指针指向可以改，指针指向的值不可以改    </p><p><code>const int* p1 = &amp;a</code>，指针指向的值只为常量。</p></li><li><p>const修饰常量—指针常量</p><p>const修饰的是常量，指针指向不可以改，指针指向的值可以更改    </p><p><code>int* const p2 = &amp;a</code>，即p2里的地址不会发生改变。</p></li><li><p>const既修饰指针，又修饰常量</p><p>const既修饰指针，又修饰常量，指针的指向和指针指向的值都不可以改变   </p><p><code>const int* const p = &amp;a</code></p></li></ul><h5 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h5><p><strong>作用</strong>:利用指针访问数组元素</p><pre class=" language-c++"><code class="language-c++">int arr[] = {1,2,3,4};int* p = arr;p++;</code></pre><h5 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h5><p><strong>作用</strong>:利用指针作函数的参数，可以修改实参的值</p><p>例如：<code>void swap(int *p,int *t)</code></p><p>注意值传递和地址传递的区别</p><h4 id="8、结构体"><a href="#8、结构体" class="headerlink" title="8、结构体"></a>8、结构体</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>结构体属于用户<a href>自定义的数据类型</a>，允许用户存储<a href>不同的数据类型</a></p><h5 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h5><p><strong>语法</strong>：</p><pre class=" language-c++"><code class="language-c++">struct 结构体名称{ 结构体成员列表};</code></pre><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = （成员1值，成员2值…)</li><li>定义结构体时顺便创建变量</li></ul><blockquote><p>结构体为用户自定义的类型，是一些数据类型的集合</p><p>struct关键字在定义时候不可以省略，在创建变量时候可以省</p></blockquote><h5 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h5><p><strong>作用</strong>:将自定义的结构头放入到数组中方便维护</p><p><strong>语法</strong>：“<a href><code>struct 结构体名 数组名[元素个数]=  {{}，{}...{}};</code></a>”</p><blockquote><p>数组作函数形参时只能为地址传递！ 值传递的形式也只是把首地址复制。</p></blockquote><h5 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h5><p><strong>作用</strong>：通过指针访问结构体中的成员</p><p>利用操作符-&gt;可以通过结构体指针访问结构体属性，表示所指向的东西的成员变量。</p><pre class=" language-c++"><code class="language-c++">struct Student s1;struct Student* p = &s1;p->score = 10;</code></pre><h5 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h5><p><strong>作用</strong>：结构体中的成员可以是另一个结构体</p><p><strong>例如</strong>: 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的的结构体</p><blockquote><p>学生结构体的声名必须在老师前。</p><p>随时间生成随机数步骤：</p><p>include &lt;ctime.h&gt;</p><p>srand = ((unsigned int)time(NULL));</p><p>int random = rand()&amp;61 +40;//按时间随机生成数字40-100</p></blockquote><h5 id="结构体作函数参数"><a href="#结构体作函数参数" class="headerlink" title="结构体作函数参数"></a>结构体作函数参数</h5><p><strong>作用</strong>:将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><p>同上函数参数-指针</p><ul><li>值传递-无法改变实参</li><li>地址传递-可以改变实参</li></ul><h5 id="结构体中const使用场景"><a href="#结构体中const使用场景" class="headerlink" title="结构体中const使用场景"></a>结构体中const使用场景</h5><p><strong>作用</strong>：用const来防止误操作，防止变量修改</p><p>可以用地址传递，减少值传递时复制数据的时间和空间，提高效率</p><p>定义函数中的形参变为<code>const student *s</code>，防止数据修改，数据仅可读。</p><h2 id="二、核心内容（面向对象编程）"><a href="#二、核心内容（面向对象编程）" class="headerlink" title="二、核心内容（面向对象编程）"></a>二、核心内容（面向对象编程）</h2><h4 id="1、内存分区模型"><a href="#1、内存分区模型" class="headerlink" title="1、内存分区模型"></a>1、内存分区模型</h4><p>代码区：存放函数的二级制代码，由操作系统进行管理的</p><p>全局区：存放全局变量和静态变量以及常量</p><p>栈区：由<a href>编译器</a>自动分配释放，存放函数的参数值，局部变量等</p><p>堆区： 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p><p>内存四区意义：不同区域存放的数据，赋予不同的<a href>声明周期</a>，给我们更大的灵活编程</p><h5 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h5><p>在程序编译后，生成了exe可执行文件，未执行该程序前分为两个区域</p><h6 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h6><p>存放cpu执行的机器指令</p><p>代码区是<a href>共享</a>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份打码即可</p><p>代码区是<a href>只读</a>的，使其只读的原因是防止程序意外的修改了它的指令</p><h6 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h6><p><a href>全局变量</a>（放在函数之外的变量）和<a href>静态变量</a>（static修饰的变量）存放于此</p><p>全局区还包含了<a href>常量区</a>，字符串常量和其他常量也存放于此（其他常量是const修饰的全局变量，const修饰的局部变量是和局部变量存放在一起）</p><p><a href>该区域的数据在程序结束之后由操作系统释放</a></p><h5 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h5><h6 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h6><p>由<a href>编译器</a>自动分配释放，存放函数的参数值（形参数据），局部变量等</p><p><a href>注意事项：</a>不要返回局部变量的地址（函数类型是返回指针类型存放地址），因为栈区开辟的数据在函数执行</p><p>后由<a href>编译器自动</a>释放</p><h6 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h6><p>有<a href>程序员分配释放</a>，若程序员不释放，程序结束之后有操作系统回收</p><p>在C++中主要利用new在堆区中开辟内存，返回的是地址，用指针接收：</p><p><code>int* p = new int(10);</code></p><h5 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h5><p>在堆区开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放用delete</p><p>利用new创建的数据，会返回该数据对应类型的指针</p><p><code>int* p = new int(10); int* arry = new int[10]</code></p><p><code>delete p; delete[] arry;</code>//指针须指向一个动态分配的数据或为空</p><h4 id="2、引用"><a href="#2、引用" class="headerlink" title="2、引用"></a>2、引用</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p><strong>作用</strong>:给变量（一段内存空间）起别名</p><p><strong>语法</strong>：数据类型 &amp;别名 = 原名</p><pre class=" language-c++"><code class="language-c++">int a = 0;int &b = a;//a和b操作的是同一块内存</code></pre><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>引用必须初始化——告诉它它是谁的别名</li><li>引用在初始化之后，不可以改变</li></ul><h5 id="做函数参数"><a href="#做函数参数" class="headerlink" title="做函数参数"></a>做函数参数</h5><p><strong>作用</strong>：函数传参时，可以利用引用让形参修饰实参</p><p><strong>优点</strong>：可以简化指针修改实参（传址）</p><pre class=" language-c++"><code class="language-c++">void changeNums(int &a,int& b);//引用传递int main(void){    int a = 10;    int b = 20;    changeNums(a,b);    //引用——其实上面的a就是下面a的一个别名    return 0;}</code></pre><blockquote><p>函数参数传递的三种方式：1、形参传递 2、地址传递 3、引用传递</p></blockquote><h5 id="做函数的返回值"><a href="#做函数的返回值" class="headerlink" title="做函数的返回值"></a>做函数的返回值</h5><p><strong>注意</strong>：不要返回<a href>局部变量</a><a href>引用</a>，因为编译器只做一次保留，然后数据会被自动释放。</p><p><strong>用法</strong>：函数调用作为左值，即返回内存空间的别名可以重新赋值</p><h5 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h5><p><strong>本质</strong>：引用的本质在c++内部实现是一个<a href>指针常量</a>,起别名，引用一旦被初始化之后就不能更改，即存放的地址不可改变。</p><pre class=" language-c++"><code class="language-c++">void func(int& ref){    ref = 100;//ref是引用，转换为*ref = 100}int main(void){    int a  = 10;    int &ref = a;//自动转化int* const ref = &a;//指针常量是指针指向不可改，也说明为什么引用不可更    ref =20;//自动发现ref是引用，自动转换为*ref = 20;}</code></pre><p><strong>结论</strong>：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但所有的指针操作编译器都帮我们做了。</p><h5 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h5><p><strong>作用</strong>:常量引用主要用来修饰形参，防止误操作</p><pre class=" language-c++"><code class="language-c++">//常量引用//使用场景，用来修饰形参，防止误操作//引用必须引用一块合法的内存空间，得是堆区和栈区const int& ref = 10;//const修饰的局部常量//加上const之后，编译器将代码修改为int temp =10;int& ref = temp;//加入const之后变为只读不可以修改</code></pre><h4 id="3、函数提高"><a href="#3、函数提高" class="headerlink" title="3、函数提高"></a>3、函数提高</h4><h5 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h5><p>在c++中函数形参列表中的形参是可以有默认值的，即如果没有传入参数时，形参为设置的默认值。</p><p><strong>语法</strong>：返回值类型 函数名(参数=默认值)</p><p><strong>注意事项</strong>：如果某个位置已经有了默认参数，那么从这个位置往后都要有默认参数；函数的<a href>声明和定义</a>中只能有一个有默认参数，否则编译器不知道按照哪个。</p><h5 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h5><p>C++中函数的形参列表里可以有占位参数，用来占位（还可以加入默认参数 ），<a href>调用函数的时候必须填补该位置</a></p><p><strong>语法</strong>：返回值类型 函数名 （数据类型）{}，</p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p><strong>作用</strong>:函数名可以相同，提高复用性，比如传入不同的参数，有不同的效果。</p><p><strong>函数重载满足的条件</strong>：</p><ul><li>同一个作用域下</li><li>函数名相同</li><li>函数参数类型不同或者个数不同或者顺序不同</li></ul><p><strong>注意</strong>：函数的<a href>返回值类型</a>不可以作为函数重载的条件</p><h6 id="函数重载的注意事项"><a href="#函数重载的注意事项" class="headerlink" title="函数重载的注意事项"></a>函数重载的注意事项</h6><ul><li>引用作为函数重载条件（const int &amp;a = 10）</li><li>函数重载碰到函数默认参数,出现二义性报错，尽量避免这种情况：(int a,int b =10)与(int a)当只传入一个参数时</li></ul><h4 id="4、类和对象"><a href="#4、类和对象" class="headerlink" title="4、类和对象"></a>4、类和对象</h4><p>C++面向对象的三大特性为：<a href>封装、继承、多态</a></p><p>C++认为万事万物皆为对象，对象上有其<a href>属性和行为</a></p><p>exp：人可以作为对象，属性有姓名、年龄、身高、体重…行为有唱、跳、rap…</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><h6 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h6><p>封装是C++面向对象的三大特征之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p>封装的意义一：</p><p>在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法</strong>:</p><pre class=" language-c++"><code class="language-c++">class 类名{访问权限: 属性 / 行为};</code></pre><p>别名：</p><p>类中的属性和行为，我们统称为<a href>成员</a></p><p>属性-成员属性-成员变量</p><p>行为-成员函数-成员方法</p><p>封装的意义二：</p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种</p><ol><li>public——公共权限——成员类内可以访问，类外可以访问</li><li>protected–保护权限——成员类内可以访问，类外不可以访问  儿子也可以访问父亲保护内容</li><li>private——私有权限——成员类内可以访问，类外不可以访问  儿子不可以访问父亲私有内容</li></ol><h6 id="struct和class"><a href="#struct和class" class="headerlink" title="struct和class"></a>struct和class</h6><p>在C++中struct和class的唯一区别就是默认的访问权限不同。</p><p><strong>区别</strong>：</p><p>struct默认权限为公共public</p><p>class默认权限为私有private</p><h6 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h6><p>优点1：将所有成员属性设置为私有，可以自己控制<a href>读写</a>权限。(用<a href>公共接口</a>实现对私有属性的读写（设置，获取）)</p><p>优点2：对于写权限，我们可以检测数据的有效性（是否符合要求）。</p><h6 id="点和圆关系的案例"><a href="#点和圆关系的案例" class="headerlink" title="点和圆关系的案例"></a>点和圆关系的案例</h6><p>将一个类拆分成两个文件：</p><p>point.h  <a href>成员函数和属性的声名</a></p><pre class=" language-c++"><code class="language-c++">#pragma once  //防止头文件重复包含#include<iostream>using namespace std;class Point{public:    void setx(int x);    int getx();    void sety(int y);    int gety();private:    int c_x;    int c_y;};</code></pre><p>point.cpp <a href>成员函数的实现</a></p><pre class=" language-c++"><code class="language-c++">#include"point.h"//Point::告诉编译器这是Point作用域下面的一个成员函数void Point::setx(int x){    c_x = x;}int Point::getx(){    return c_x;}void Point::sety(int y){    Point::c_y = y;}int Point::gety(){    return c_y;}</code></pre><h5 id="对象的初始化清理"><a href="#对象的初始化清理" class="headerlink" title="对象的初始化清理"></a>对象的初始化清理</h5><ul><li>在生活中我们所购买的点子产品大多都有恢复出厂设置，在某一天我们不使用的时候清楚自己的数据来保证自己信息的安全。</li><li>C++中的面向对象来源生活，每个对象也会有初识设置以及对象销毁前的清理数据的设置。</li></ul><h6 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h6><p>对象的<a href>初始化和清理</a>也是两个非常重要的安全问题。</p><p>​        一个对象或者变量没有初识状态，对其使用后的后果是未知的。</p><p>​        同样的使用完一个对象或者变量，没有及时进行清理，也会造成一定的安全问题。</p><p>C++利用了<a href>构造函数和析构函数</a>解决上述问题，这两个函数将会被<a href>编译器自动斓用</a>，完成对象初始化和清理</p><p>工作。对象的初始化和清理工作是编译器强制要我们做的事情，<a href>因此如果我们不提供构造和析构</a>，编译器会</p><p>提供，是编译器提供的构造函数和析构函数是<a href>空实现</a>。</p><p><strong>构造函数</strong>：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p><p><strong>析构函数</strong>：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</p><p><strong>构造函数语法</strong></p><pre class=" language-c++"><code class="language-c++">类名(){}</code></pre><ol><li>构造函数没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生<a href>重载</a></li><li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次</li></ol><p><strong>析构函数语法</strong></p><pre class=" language-c++"><code class="language-c++">~类名(){}</code></pre><ol><li>析构函数没有返回值也不写void</li><li>函数名称与类名相同，在名称前加上~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol><h6 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h6><p>两种分类方式：</p><ul><li>按参数分为:有参构造和无参构造（默认）</li><li>按类型分为:普通构造（除了拷贝之外的）和拷贝构造（<code>Person（const Person &amp;p）</code>，将传入的对象拷贝到自己身上）</li></ul><p>三种调用方式：</p><ul><li>括号法</li></ul><pre class=" language-c++"><code class="language-c++">    Person p;//默认构造函数调用    /*注意：使用默认构造函数的时候，不要加(),编译器会认为这是一个函数的声明    例如：Person p1();不会认为在创建对象*/    Person p2(10);//有参构造函数调用    Person p3(p2);//拷贝构造函数调用    cout << "p2的年龄为" << p2.age << endl;    cout << "p3的年龄为" << p3.age << endl;</code></pre><ul><li>显示法</li></ul><pre class=" language-c++"><code class="language-c++">Person p1;//无参    Person p2 = Person(10);//有参    Person p3 = Person(p2);//拷贝    //如果把等号右边的式子单独拿出来    //Person(10)这是一个匿名对象-特点——当前行执行结束后，系统会立即回收掉匿名对象    //注意：不要利用拷贝函数初始化匿名对象-编译器会认为Person(p3) == Person p3 编译器会认为是对象的声明    //Person(p3)</code></pre><ul><li>隐式转换法</li></ul><pre class=" language-c++"><code class="language-c++">Person p4 = 10;//相当与Person p4 = Person(10);Person p5 = p4;//拷贝构造</code></pre><h6 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h6><p>C++中拷贝构造函数调用时机通常有三种情况：</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值（形参是实参的复制）</li><li>以<a href>值方式返回</a>局部对象(拷贝出去)</li></ul><h6 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h6><p>默认情况下，C++编译器至少给一个类添加三个函数：</p><ol><li>默认构造函数(无参、函数体为空)</li><li>默认析构函数(无参、函数体为空)</li><li>默认拷贝函数构造函数，对属性<a href>值拷贝</a></li></ol><p><strong>构造函数调用规则如下:</strong></p><ul><li>如果用户定义<a href>有参构造</a>函数，C++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义<a href>拷贝构造</a>函数，C++不会再提供其他构造函数</li></ul><h6 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h6><p>深浅拷贝是面试的一个经典的问题，也是常见的一个坑。</p><p><strong>浅拷贝</strong>：简单的赋值拷贝操作。</p><p><strong>深拷贝</strong>：在堆区中重新申请空间，进行拷贝操作。</p><p><strong>浅拷贝带来的问题——内存重复释放</strong>：</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//深拷贝与浅拷贝问题class Person{public:    Person()    {        cout << "Person的默认构造函数调用" << endl;    }    Person(int age,int height)    {        m_Height = new int(height);        m_Age = age;        cout << "Person的有参构造函数调用" << endl;    }    Person(const Person& p)    {        cout << "Person的拷贝构造函数调用" << endl;        m_Age = p.m_Age;        m_Height = p.m_Height;编译器默认实现的就是这行代码            }    ~Person()    {        //将堆区开辟的数据进行释放        if (m_Height !=NULL)        {            delete m_Height;//删除指针指向的地址空间的数据            m_Height = NULL;//让指针指向空        }        cout << "Person的析构构造函数调用" << endl;    }     int m_Age;    int* m_Height;//为什么要用指针——要把身高开辟到堆区};void test(){    Person p1(18,166);    cout << p1.m_Age<<"\t" << *p1.m_Height << endl;    Person p2(p1);    cout << p2.m_Age<<"\t" <<*p2.m_Height<< endl;}int main(void){    test();    system("pause");    return 0;}</code></pre><p>![image-20230914105808870](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230914105808870.png)</p><p><strong>解决</strong>：</p><p><strong>深拷贝</strong>——手动创建拷贝构造函数</p><pre class=" language-c++"><code class="language-c++">Person(const Person& p){    cout << "Person的拷贝构造函数调用" << endl;    m_Age = p.m_Age;    //m_Height = p.m_Height;编译器默认实现的就是这行代码    //深拷贝操作    m_Height = new int(*p.m_Height);//解引用，将值复制，新开辟地址}</code></pre><p><strong>总结</strong>：</p><p>如果有<a href>属性在堆区开辟</a>的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p><h6 id="初识化列表"><a href="#初识化列表" class="headerlink" title="初识化列表"></a>初识化列表</h6><p><strong>作用</strong>：</p><p>C++提供了初始化列表语法，用来初始化对象。另一个方式是构造函数（传统）</p><p><strong>语法</strong>：</p><p>构造函数()：属性1（值1），属性2（值2）…{}</p><p>为什么：<a href>真正的初始化发生在构造函数语句前，即初始化列表处</a></p><pre class=" language-c++"><code class="language-c++">Person(int a,int b,int c) :m_A(a), m_B(b), m_C(c)    {    }</code></pre><h6 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h6><p>C++中类的成员可以是另一个类的对象，我们称该成员为对象成员</p><p><strong>例如</strong>:</p><pre class=" language-c++"><code class="language-c++">class A{}class B{    A a;}</code></pre><p>构造顺序？</p><p><strong>A先被构造</strong></p><p>当其他类的对象作为本类的成员时，构造时先构造其他类的对象，再构造自身。先有内，后有外</p><p><strong>析构呢</strong>？与构造函数相反。</p><p>自身的析构函数先进行，之后其它类再进行。</p><h6 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h6><p>静态成员就是在成员变量和成员函数前面加上关键字static，称为静态成员</p><p><strong>静态<a href>成员</a>分为</strong>：</p><ul><li><p>静态成员变量</p><ul><li><p>所有对象共享同一份数据（有两种访问方式：1、类名 p.a  2、实例化对象 Person::a）,类外访问不到</p><p>私有的静态成员变量</p></li><li><p>在编译阶段分配内存（存放在程序运行前的全局区中）</p></li><li><p>类内声明，类外初始化 （必须有初始值）</p><pre class=" language-c++"><code class="language-c++">int Person::m_id = 100;//这是Person作用域下的成员变量类外初始化</code></pre></li></ul></li><li><p>静态成员函数</p><ul><li><p>所有成员共享同一个函数（跟静态成员变量一样有两种访问方式）</p><pre class=" language-c++"><code class="language-c++">//通过对象访问    Person p;    p.func();//通过类名也可以访问    Person::func();</code></pre></li><li><p>静态成员函数<a href>只能</a>访问静态成员变量（也有访问权限）</p><blockquote><p>访问非静态成员变量时，不能区分是哪个实例化对象的变量（python中有self绑定）</p></blockquote></li></ul></li></ul><h5 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h5><h6 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h6><p>在C++中，类内的成员变量和成员函数分开存储，</p><p><strong>只有<a href>非静态成员变量</a>才属于类的对象上。</strong></p><p>（只有非静态成员变量的大小算进类的大小中，其他的都不算。）</p><p><strong>空对象的大小是1，为的是区分不同类在内存中的占用位置。</strong>每个空对象都应该有独立的地址空间</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//成员变量和成员函数是分开存储的class Person{    int m_A;//非静态成员属于类对象上的。     static int m_B;//静态的成员变量不属于类的对象上。    void func() {}//非静态成员函数不属于类的对象上    static void func2(){}//静态成员函数不属于类的对象上};int Person::m_B = 10;void test01(){    Person p;    //空对象占用内存空间为1    /*C++编译器给每个空对象也分配一个字节的空间，为的是区分空对象在占内存的位置，    每一个空对象也应该有一个独一无二的内存地址*/    cout << sizeof(p) << endl;}int main(void){    test01();    system("pause");    return 0;}</code></pre><h6 id="this指针的概念"><a href="#this指针的概念" class="headerlink" title="this指针的概念"></a><strong>this指针的概念</strong></h6><p>通过上一个知识点《成员变量和成员函数是分开存储的》我们知道C++中成员变量和成员函数是分开存储的。</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会公用一块代码。</p><p>那么问题是：这一块代码是如何区分是哪个对象调用自己的呢？</p><p>C++通过提供特殊的对象指针，this指针，解决上述问题。</p><p>this指针<a href>指向被调用的成员函数所属的对象</a>。(<a href>谁调的，this就指向谁</a>)</p><p>this指针是隐含每个非静态成员函数内的一种指针。</p><p>this指针不需要定义，直接使用即可。</p><p><strong>this指针的用途：</strong></p><ul><li>当<a href>形参和成员变量同名</a>时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><p><strong>解决名称冲突</strong></p><p><strong>返回对象本身用*this</strong></p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class Person{public:    Person(int age)    {        //this指针指向的是被调函数的成员函数所属的对象        //这里指向的就是p        this->age = age;    }    //返回本体要用应用的方式进行返回    //这里返回值如果是Person，就创建了一个新的对象    Person& PersonAddPerson(Person &p)    {        this->age += p.age;        return *this;    }    int age;//注意起名规范也可以解决名字冲突的问题};//解决对象冲突void test(){    Person p(18);    cout << p.age << endl;}//返回对象本身用*thisvoid test01(){    Person p1(10);    Person p2(10);    p2.PersonAddPerson(p1);//将p1和p2的加在一起    //多次追加,return *this;    //链式编程思想    p2.PersonAddPerson(p1).PersonAddPerson(p1);    cout << p2.age << endl;}int main(void){    test01();    system("pause");    return 0;}</code></pre><h6 id="空指针返回成员函数"><a href="#空指针返回成员函数" class="headerlink" title="空指针返回成员函数"></a>空指针返回成员函数</h6><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针，如果用到this指针，需要加以判断来保证代码的健壮性</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class Person{public:    void ShowClassName()    {        cout << "this is Person class" << endl;    }    void ShowPersonAge()    {            //提高健壮性，空的就直接返回，防止代码崩溃        if (this == NULL)        {            return;        }        //报错原因是因为传入的指针是NULL——无中生有，用一个空指针访问里面的属性 ,而且this还没有指向哪个实例化对象。        cout << this->m_Age << endl;    }    int m_Age;};void test(){    Person* p = NULL;    p->ShowClassName();    p->ShowPersonAge();}int main(void){    test();    system("pause");    return 0;}</code></pre><h6 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h6><p><strong>常函数</strong>：</p><ul><li>成员函数后加const后我们称这个函数为**<a href>常函数</a>**</li><li>常函数不可以修改成员属性</li><li>成员属性声明时加关键字<a href>mutable</a>后，在常函数中依然可以<a href>修改</a></li></ul><p><strong>常对象</strong>：</p><ul><li>声明对象前const称该对象为常对象</li><li><a href>常对象只能调用常函数</a>（因为只有常函数中的成员属性不可改变）</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//常函数class Person{public:    //this指针的本质是指针常量，指针的指向(地址)是不可以修改的    //就相当于Person *const this;    //在成员函数后面加const修饰的是this指向，让指针指向的值也不可以修改    void showPerson() const//加个const就不允许修改了，相当于const Person *const this    {        this->m_b = 100;        //this = NULL;this指针是不可以修改指针的指向的    }    int m_a;    mutable int m_b;//加了mutable修饰的特殊变量，即使在常函数,常对象中，也可以修改这个值    void func()    {        m_a = 100;//在普通成员函数中是可以修改的    }};void test(){    Person P;    P.showPerson();}//常对象void test1(){    const Person p;//在对象前加const，变为常对象    //p.m_a = 100;    p.m_b = 100;    //常对象只能调用常函数     p.showPerson();    //p.func();常对象不能调用普通成员函数，因为普通成员函数可以修改属性。    }int main(void){    test();    system("pause");    return 0;}</code></pre><blockquote><p>this指针本质是指针常量</p></blockquote><h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5><p>友元，就是朋友的意思。</p><p>客厅就是Public，你的卧室就是Private，客厅所有人都可以进去，但是你的卧室只有和你亲密的人可以进。</p><p>在程序中，有些<a href>私有属性</a>也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术。</p><p>友元的目的就是让一个函数或者类访问另一个类中的<a href>私有元素</a>。</p><p><strong>友元的关键字——friend</strong></p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h6 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h6><p><strong>就是将此函数在<a href>类的最上面</a>写一个声明，前面加一个friend。</strong></p><pre class=" language-c++"><code class="language-c++">class Building {    //goodgay全局函数是Building类的一个好朋友，可以访问你家的卧室(私有成员)    friend void goodgay(Building* building);public:    Building()    {        m_SittingRoom = "客厅";        m_BedRoom = "卧室";    }public:    string m_SittingRoom;private:    string m_BedRoom;};</code></pre><h6 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h6><p><strong>一个类在另一个中friend class xx</strong></p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;//在前面先声明一下class Building;class GoodGay{public:    GoodGay();public:    void visit();//参观函数 访问Building中的属性    Building* building;//构造函数可以直接调用了？};class Building{    //GoodGay是Building类的好朋友，可以访问其私有属性    friend class GoodGay;public:    Building();public:    string m_SittingRoom;private:    string m_BedRoom;};//在类外写成员函数Building::Building(){    m_SittingRoom = "客厅";    m_BedRoom = "卧室";}GoodGay::GoodGay()//类外实现类中的成员函数，在类中声名成员函数{    //创建一个Building对象，在堆区，返回一个指针    building = new Building;}void GoodGay::visit(){    cout << "好基友正在访问你的" << building->m_SittingRoom << endl;    cout << "好基友正在访问你的" << building->m_BedRoom << endl;}void test(){    GoodGay gy;    gy.visit();}int main(void){    test();    system("pause");    return 0;}</code></pre><blockquote><p>类外实现类中的成员函数，在类中声名成员函数,跟.h文件中声名函数，在.cpp文件中实现函数同理</p></blockquote><h6 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h6><p><strong>告诉编译器 另一个类中的xx成员函数作为本类的好朋友，可以访问私有函数</strong></p><pre class=" language-c++"><code class="language-c++">//告诉编译器 GoodGay类中的visit成员函数作为本类的好朋友，可以访问私有函数    friend void GoodGay::visit();</code></pre><h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p>运算符重载的<strong>概念</strong>:对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p><ul><li>成员函数重载</li><li>全局函数重载</li></ul><h6 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h6><p><strong>作用</strong>：实现两个自定义数据类型相加的运算。</p><p>例如：内置的类型相加编译器知道该怎么进行运算，如果是两个自定义出来的类型，两个Person相加，编译器就不知道该怎么运算了</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;//加号运算符重载class Person{public:    //1.成员函数重载+    /*Person operator+(Person& p)    {        Person temp;        temp.m_A = this->m_A + p.m_A;        temp.m_B = this->m_B + p.m_B;        return temp;    }*/    int m_A;    int m_B;};//2.全局函数重载+Person operator+(Person& p1, Person& p2){    Person temp;    temp.m_A = p1.m_A + p2.m_A;    temp.m_B = p1.m_B + p2.m_B;    return temp;}//函数，函数重载版本Person operator+(Person& p1, int num){    Person temp;    temp.m_A = p1.m_A + num;    temp.m_B = p1.m_B + num;    return temp;}void test01(){    Person p1;    p1.m_A = 10;    p1.m_B = 10;    Person p2;    p2.m_A = 10;    p2.m_B = 10;    //成员函数重载本质调用    //Person p3 = p1.operator+(p2);    //Person p3 = p1 + p2;//可以简化成这种形式    //全局函数重载的本质调用    //Person p3 = operator+(p1,p2);    /*cout << p3.m_A << endl;    cout << p3.m_B << endl;*/    //运算符重载也可以发生函数重载    Person p3 = p1 + 10;    cout << p3.m_A << endl;    cout << p3.m_B << endl;}int main(void){{    test01();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>：</p><ol><li>对于内置的数据类型的表达式的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ol><h6 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h6><p><strong>作用</strong>：可以输出自定义的类型</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class Person{    friend ostream& operator<<(ostream& cout, Person& p);public:    Person(int a, int b)    {        m_A = a;        m_B = b;    }    //利用成员函数重载左移运算符p.operator<<(cout)简化版本p<<cout    //一般我们不会利用成员函数来重载<<运算符，因为无法实现cout在左边    /*void operator<<(ostream &cout,Person &p)    {        cout << p.m_A << endl;        cout << p.m_B << endl;    }*/private:    int m_A;    int m_B;};//只能利用全局函数来重载左移运算符ostream& operator<<(ostream &cout, Person &p) //这样写的本质就是operator<<(cout,p)简化版本就是cout<<p;而且是链式编程的思想 {    cout << p.m_A << endl;    cout << p.m_B << endl;    return cout;}void test(){    Person p(10,10);    cout << p << "hello world" << endl;}int main(void){    test();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>：重载左移运算符配合友元可以实现输出自定义数据类型。</p><p>这里给出不推荐的类内实现重载左移运算符：</p><pre class=" language-c++"><code class="language-c++">void operator<<(ostream &cout)    {        cout << this->m_A;        cout << this->m_B;    }//使用p<<cout;</code></pre><h6 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h6><p><strong>作用</strong>：通过重载递增运算符，实现自己的<a href>整型数据</a></p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//重载递增运算符class MyInteger{    friend ostream& operator<<(ostream& cout, MyInteger myint);public:    MyInteger()    {        m_Num = 0;    }    //重载++运算符——前置    //返回引用是为了一直对一个数据进行递增操作    MyInteger& operator++()//链式编程，只对一个东西一直操作    {        ++m_Num;        return *this;    }    //重载++运算符——后置    MyInteger operator++(int)//这个int在这里作为占位参数，用来区分前置递增和后置递增    {        MyInteger temp = *this;        m_Num++;        return temp;        //后置递增要返回值，因为如果返回引用，这里相当于返回的是一个局部对象的引用。        //局部对象在当前函数执行完毕之后就被释放掉了，还要返回引用就是非法操作。    }private:    int m_Num;};//全局函数重载左移运算符，链式编程ostream& operator<<(ostream& cout, MyInteger myint){    cout << myint.m_Num << endl;    return cout; }void test(){    MyInteger myint;    cout << ++(++myint);    cout <<myint;}void test02(){    MyInteger myint;    cout << myint++ << endl;    cout << myint << endl;}int main(void){    //test();    test02();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>:前置递增返回引用，后置递增返回值(不能链式相加)</p><h6 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h6><p>C++编译器至少给一个类添加4个函数(前三个之前已经讲过了)</p><ol><li><p>默认构造函数(无参，函数体为空)</p></li><li><p>默认析构函数(无参，函数体为空)</p></li><li><p>默认拷贝构造函数，对属性进行值拷贝</p></li><li><p>赋值运算符operator=，对属性进行值拷贝 (简单的浅拷贝)</p></li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。</p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class Person{public:    Person(int age)    {        m_Age = new int(age);    }    ~Person()    {        if (m_Age != NULL)        {            delete m_Age;            m_Age = NULL;        }    }    //重载赋值运算符    Person& operator=(Person &p)    {        //编译器默认提供的是浅拷贝操作        //m_Age = p.m_Age;        //应该先判断自身是否有属性在堆区，如果有先释放干净，然后再深拷贝。        if (m_Age != NULL)        {            delete m_Age;            m_Age = NULL;        }        //深拷贝操作        m_Age = new int(*p.m_Age);        return *this;    }    int *m_Age;};void test1(){    Person p1(18);    Person p2(20);    Person p3(30);    p3 = p2 = p1;    cout << *(p1.m_Age) << endl;    cout << *(p2.m_Age) << endl;    cout << *(p3.m_Age) << endl;}int main(void){    test1();    system("pause");    return 0;}</code></pre><h6 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h6><p><strong>作用</strong>：重载关系运算符，可以让两个自定义类型对象进行对比操作</p><pre class=" language-c++"><code class="language-c++">//重载==    bool operator==(Person &p)    {        if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)        {            return true;        }        else        {            return false;        }    }    bool operator!=(Person &p)    {        if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)        {            return false;        }        else        {            return true;        }    }</code></pre><h6 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h6><ul><li>函数调用运算符()也可以重载（<a href>类名（）</a>）</li><li>由于重载后使用的方式非常像函数的调用，因此称为<a href>仿函数</a></li><li>仿函数没有固定写法，非常灵活</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;//函数调用运算符重载class MyPrint{public:    //重载函数调用运算符    void operator()(string text)    {        cout << text << endl;    }    };class MyAdd{public:    int operator()(int a, int b)    {        return a + b;    }};void test(){    MyPrint myprint;    myprint("hello world");    MyAdd myadd;    cout << myadd(1, 2) << endl;    //匿名函数对象——特点:当前行被执行完立即释放    cout << MyAdd()(100,100) << endl;}int main(void){    test();    system("pause");    return 0;}</code></pre><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中:</p><p>![在这里插入图片描述](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center.png)</p><p>我们发现，定义这些类的时候，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p><strong>这时候我们就可以考虑利用继承的技术，减少重复代码量。</strong></p><h6 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h6><p>例如我们看到很多网站中，都有<a href>公共</a>的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同。</p><p>接下里我们分别利用普通写法和继承写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现</strong>：</p><p>复制粘贴</p><p><strong>继承方法实现</strong>：</p><pre class=" language-c++"><code class="language-c++">class Cpp: public Basepage</code></pre><p><strong>总结</strong>：<br><strong>继承的好处</strong>：减少重复代码</p><p><strong>语法</strong>：class 子类:继承方式 父类   </p><p>子类也称派生类，父类也称基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过来的表现其<a href>共性</a>，而新增加的成员体现其<a href>个性</a>。</p><h6 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h6><pre class=" language-c++"><code class="language-c++">继承的语法——class 子类 :继承方式 父类</code></pre><p><strong>继承方式一共有三种</strong>：</p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p>![img](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center.png)</p><h6 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h6><p><strong>问题</strong>：从父类继承过来的对象，哪些属于子类对象？</p><p><strong>父类中所有的非静态成员属性都会被子类继承下去</strong>。</p><p><strong>父类中私有的成员属性是被编译器给隐藏了，因此访问不到，但是确实被继承下去了</strong></p><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//继承中的对象模型class Base{public:    int m_A;protected:    int m_B;private:    int m_C;};class Son:public Base {public:    int m_D;};void test01(){    //父类中所有的非静态成员属性都会被子类继承下去    //父类中私有的成员属性是被编译器给隐藏了，因此访问不到，但是确实被继承下去了    cout << "sizeof of son:" << sizeof(Son) << endl;//结果是16 = 12 + 4}int main(void){    test01();    system("pause");    return 0;}</code></pre><p><strong>利用VS的开发人员命令提示工具查看对象模型</strong><br>![在这里插入图片描述](E:\My Blog\Blog\source_posts\C++巩固.assets\20210709154256385.png)</p><ol><li>打开工具</li><li>跳转到你cpp文件所在的盘</li><li>cd文件目录下</li><li>输入命令：cl /d1 reportSingleClassLayout类名 文件名</li></ol><h6 id="继承中构造和析构的顺序"><a href="#继承中构造和析构的顺序" class="headerlink" title="继承中构造和析构的顺序"></a>继承中构造和析构的顺序</h6><p><strong>子类继承父类后，当创建子类时，也会调用父类的构造函数。</strong></p><p>问题：父类和子类的构造函数和析构顺序怎么样的呢？</p><p><strong>先构造父类，再构造子类</strong></p><p><strong>先析构子类，再析构父类</strong></p><p><strong>创建子类对象的同时也会<a href>先创建</a>一个父类对象</strong>。</p><h6 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h6><p>问题：当子类与父类出现同名的成员。如何通过子类对象，访问到子类或父类中同名的数据呢?</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加<strong>作用域</strong></li></ul><pre class=" language-c++"><code class="language-c++">void test01(){    Son son;    cout <<son.m_A<< endl;    //如果要通过子类对象访问到父类中的同名成员，需要加作用域。    cout <<son.Base::m_A<< endl;}</code></pre><p><strong>总结</strong>：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会<a href>隐藏</a>父类中同名成员函数，加作用域可以访问到父类同名函数</li></ol><h6 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h6><p>问题:继承中同名的静态成员在子类对象上是如何进行访问的呢？</p><p>静态成员和非静态成员出现同名，处理方式一致。</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加<a href>作用域</a></li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class Base{public:    static void func()    {        cout << "父类静态成员函数调用" << endl;    }    static void func(int a)    {        cout << "父类静态成员重载函数调用" << endl;    }    static int m_A;};int Base::m_A = 100;class Son :public Base{public:    static void func()    {        cout << "子类静态成员函数调用" << endl;    }    static int m_A;};int Son::m_A = 200;//同名静态成员void test(){    //通过对象访问    Son son1;    cout << "通过对象访问" << endl;    cout << son1.m_A << endl;    cout << son1.Base::m_A << endl;    //通过类名访问    cout << "通过类名访问" << endl;    cout << Son::m_A << endl;    //第一个::代表通过类名方式访问，第二个::代表访问父类作用域下    cout << Son::Base::m_A << endl;}//同名静态函数void test01(){    //通过对象访问    Son son2;    cout << "通过对象访问" << endl;    son2.func();    son2.Base::func();      //通过类名访问    cout << "通过类名访问" << endl;    Son::func();    Son::Base::func();    //父类同名重载成员函数调用    //子类出现和父类同名的静态成员函数，也会隐藏掉父类中所有同名成员函数(重载)    //如果想访问父类中被隐藏的同名成员，需要加作用域    Son::Base::func(100);}int main(void){    test();    cout << "我是分割线------" << endl;    test01();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和类名)</p><h6 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h6><p>C++允许一个类继承多个类</p><p>语法:</p><pre class=" language-c++"><code class="language-c++">class 子类:继承方式 父类1，继承方式 父类2</code></pre><p>多继承可能会引发父类中有同名成员出现，需要加<a href>作用域区分</a></p><p><strong>C++实际开发中不建议使用多继承</strong></p><p><strong>总结</strong>：多继承中如果父类中出现了同名情况，子类使用时要加作用域。</p><h6 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h6><p><strong>菱形继承概念</strong>：</p><p>两个派生类继承同一个基类，又有某个类同时继承这两个派生类，这种继承称为菱形继承，或者钻石继承。</p><p><strong>典型的菱形继承案例</strong></p><p>![在这里插入图片描述](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center.png)</p><p><strong>菱形继承问题</strong>：</p><ol><li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生<a href>二义性</a>。</li><li>草泥马继承动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</li></ol><p>vbptr——虚基类（最上边的父类）,指向虚基表（vbtable）,里面记录了偏移量</p><p>继承了两个指针，两个指针通过<a href>偏移量</a>找到了唯一的数据。</p><img src="/2023/08/01/c-gong-gu/My Blog\Blog\source\_posts\C++巩固.assets\image-20230923160432416.png" alt="image-20230923160432416" style="zoom: 67%;"><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Animal<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token keyword">int</span> m_Age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//利用虚继承可以解决菱形继承问题</span><span class="token comment" spellcheck="true">//在继承之前加上关键字virtual变为虚继承</span><span class="token comment" spellcheck="true">// Animal类称为虚基类</span><span class="token comment" spellcheck="true">//羊</span>class Sheep<span class="token punctuation">:</span>virtual public Animal<span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//驼</span>class Tuo<span class="token punctuation">:</span>virtual public Animal<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//羊驼</span>class SheepTuo <span class="token punctuation">:</span>public Sheep<span class="token punctuation">,</span>public Tuo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    SheepTuo st<span class="token punctuation">;</span>    st<span class="token punctuation">.</span>Sheep<span class="token punctuation">:</span><span class="token punctuation">:</span>m_Age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>    st<span class="token punctuation">.</span>Tuo<span class="token punctuation">:</span><span class="token punctuation">:</span>m_Age <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//当菱形继承，当两个父类拥有相同的数据，需要加作用域来区分</span>    cout <span class="token operator">&lt;&lt;</span> st<span class="token punctuation">.</span>Sheep<span class="token punctuation">:</span><span class="token punctuation">:</span>m_Age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> st<span class="token punctuation">.</span>Tuo<span class="token punctuation">:</span><span class="token punctuation">:</span>m_Age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> st<span class="token punctuation">.</span>m_Age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两个虚基指针和一个整形数据  4*3 = 12</span>    <span class="token comment" spellcheck="true">//这份数据我们知道，只有一份就可以了，菱形继承导致数据有两份，资源浪费</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>总结</strong>：</p><ol><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义。</li><li>利用<a href>虚继承</a>可以解决菱形继承问题——<strong>virtual</strong></li></ol><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p><strong>多态是C++面向对象三大特性之一</strong></p><h6 id="多条的基本概念"><a href="#多条的基本概念" class="headerlink" title="多条的基本概念"></a>多条的基本概念</h6><p>多态分为两种</p><ul><li>静态多态:<a href>函数重载</a>和<a href>运算符重载</a>属于静态多态，复用函数名</li><li>动态多态:<a href>派生类</a>和<a href>虚函数</a>实现运行时多态</li></ul><p>静态多态和动态多态的区别</p><ul><li>静态多态的函数地址早绑定 - <a href>编译</a>阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - <a href>运行</a>阶段确定函数地址</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class Animal{public:    //加上virtual变成虚函数,实现地址晚绑定    virtual void speak()    {        cout << "动物在说话"<< endl;    }};class Cat :public Animal{public:    void speak()    {        cout << "小猫在说话" << endl;    }};class Dog : public Animal{public:    void speak()    {        cout << "小狗在说话" << endl;    }};//执行说话的函数//地址早绑定，在编译阶段就确定函数地址//如果想让猫说话，那么这个函数的地址就不能提前绑定，需要在运行阶段进行绑定//动态多条满足条件/*1.有继承关系2.子类重写父类的虚函数*///重写要求:函数返回值类型 函数名 参数列表 完全相同 //动态多态的使用/*父类的指针或者引用 指向子类的对象//Animal &animal = cat;*/void doSpeak(Animal &animal)//Animal &animal = cat;{    animal.speak();//此时函数的地址不能确定,得看传入得是什么}void test01(){    Cat cat;    doSpeak(cat);    Dog dog;    doSpeak(dog);}int main(void){    test01();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态的使用条件</p><ul><li><a href>父类指针或引用指向子类对象</a></li></ul><p>重写:函数返回值类型，函数名，参数列表完全一致称为<a href>重写</a></p><h6 id="多态的原理剖析"><a href="#多态的原理剖析" class="headerlink" title="多态的原理剖析"></a>多态的原理剖析</h6><p><strong>虚函数(表)指针</strong></p><p> <strong>虚函数(表)指针</strong></p><pre class=" language-c++"><code class="language-c++">vfptr    v - virtual    f - functio n    prt - pointer</code></pre><p><strong>虚函数表</strong></p><p>表内记录一个虚函数的地址</p><pre class=" language-c++"><code class="language-c++">vftable    v - virtual    f - functio n</code></pre><p>当子类重写父类的虚函数后，<a href>子类中的虚函数表内部会替换成子类的虚函数地址</a></p><p>![img](E:\My Blog\博客文档\C++巩固.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjA0MzMw,size_16,color_FFFFFF,t_70#pic_center-16954588253216.png)</p><h6 id="多态案例1——计算器类"><a href="#多态案例1——计算器类" class="headerlink" title="多态案例1——计算器类"></a>多态案例1——计算器类</h6><p>案例描述:</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类。</p><p><strong>多态的优点</strong>：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;//利用多态实现计算器//实现计算器抽象类class AbstractCalculator{public:    virtual int getResult()    {        return 0;    }    int m_Num1;    int m_Num2;};//加法计算器类class AddCalculator :public AbstractCalculator{public:    int getResult()    {        return m_Num1 + m_Num2;    }};//减法计算器类class SubCalculator :public AbstractCalculator{public:    int getResult()    {        return m_Num1 - m_Num2;    }};//乘法计算器类class MulCalculator :public AbstractCalculator{public:    int getResult()    {        return m_Num1 * m_Num2;    }};void test(){    //多态使用条件    //父类指针或者引用指向子类对象    //加法    AbstractCalculator* abc = new AddCalculator;//父类指针指向子类对象    abc->m_Num1 = 10;    abc->m_Num2 = 10;    cout << abc->m_Num1 << "+" << abc->m_Num2 << "=" << abc->getResult() << endl;    //堆区数据，手动开辟手动释放    delete abc;//堆区的数据被销毁了，但是指针的类型没有变    // 减法    abc = new SubCalculator;    abc->m_Num1 = 10;    abc->m_Num2 = 10;    cout << abc->m_Num1 << "-" << abc->m_Num2 << "=" << abc->getResult() << endl;    delete abc;}int main(void){    test();    system("pause");    return 0;}</code></pre><p>多态带来的好处：</p><ol><li>组织结构清晰，哪出错了马上定位到。</li><li>可读性强</li><li>对于前期和后期扩展以及维护性高</li></ol><p><strong>总结</strong>：C++开发提倡利用多态设计程序框架，因为多态优点很多</p><h6 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h6><p>在多态中，通常父类汇中虚函数的实现是<a href>毫无意义</a>的，主要都是调用子类<a href>重写</a>的内容</p><p>因此可以将虚函数改为纯虚函数</p><pre class=" language-c++"><code class="language-c++">纯虚函数语法virtual 返回值类型 函数名 (参数列表) = 0;</code></pre><p>当类中有了纯虚函数，这个类也称为<a href>抽象类</a></p><p><strong>抽象类特点</strong>:</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;//纯虚函数和抽象类class Base{public:    //只要有一个纯虚函数,这个类称为抽象类    //特点;无法实例化对象    virtual void func() = 0;//注意:不要忘掉virtual!    //抽象类的子类必须要重写父类中的纯虚函数，否则也属于抽象类};class Son :public Base{public:    void func()    {        cout << "func函数调用" << endl;    }};void test(){    //Base b1; 抽象类无法实例化对象    Son s1;//子类重写父类的虚函数，否则无法实例化对象    Base* abc = new Son;    abc->func();}int main(void){    test();    system("pause");    return 0;}</code></pre><h6 id="多态案例2——制作饮品"><a href="#多态案例2——制作饮品" class="headerlink" title="多态案例2——制作饮品"></a>多态案例2——制作饮品</h6><p>案例描述:制作饮品的大致流程为:煮水-冲泡-倒入杯中-加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶水</p><pre class=" language-c++"><code class="language-c++"> #include<iostream>using namespace std;//多态案例-制作饮品class AbstractDrinking{public:    //煮水    virtual void Boil() = 0;    //冲泡     virtual void Brew() = 0;    //倒入杯中    virtual void Pour() = 0;        //加入辅料    virtual void PutSomething() = 0;    //制作饮品    void makeDrink()    {        Boil();        Brew();        Pour();        PutSomething();    }};//制作咖啡class Coffee :public AbstractDrinking{public:    //煮水    virtual void Boil()    {        cout << "把水煮开" << endl;    }    //冲泡     virtual void Brew()    {        cout << "冲泡咖啡" << endl;    }    //倒入杯中    virtual void Pour()    {        cout << "倒入杯中" << endl;    }    //加入辅料    virtual void PutSomething()    {        cout << "加入糖和牛奶" << endl;    }};//制作茶水class Tea :public AbstractDrinking{public:    //煮水    virtual void Boil()    {        cout << "把矿泉水煮开" << endl;    }    //冲泡     virtual void Brew()    {        cout << "冲泡茶叶" << endl;    }    //倒入杯中    virtual void Pour()    {        cout << "倒入杯中" << endl;    }    //加入辅料    virtual void PutSomething()    {         cout << "加入柠檬" << endl;    }};//制作函数void DoWork(AbstractDrinking* abs)//父类指针指向子类对象AbstractDrinking* abs = new Coffee;{    abs->makeDrink();    delete abs;//手动释放    //堆区的数据被销毁了但是指针的类型没变}//制作void test(){    DoWork(new Coffee);    cout << "------我是分割线------" << endl;    DoWork(new Tea);}int main(void){    test();    system("pause");    return 0;}</code></pre><blockquote><p>同一个接口,不同的输入有不同的输出,这就是多态</p></blockquote><h6 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h6><p>多态使用的时候，如果<a href>子类中有属性开辟到堆区</a>(new)，那么父类指针在释放的时无法调用到子类的析构代码</p><p><strong>解决方法</strong>:将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性:</p><ul><li>可以解决<a href>父类指针释放子类对象</a></li><li>都需要有具体的含函数实现</li></ul><p>虚析构和纯虚构的区别：</p><ul><li>如果是<a href>纯虚</a>析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构语法</strong>;</p><pre class=" language-c++"><code class="language-c++">virtual ~类名(){}</code></pre><p><strong>纯虚析构语法</strong>：</p><pre class=" language-c++"><code class="language-c++">virtual ~类名() = 0;//声明1类名::~类名(){}</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<string>using namespace std;//虚析构和纯虚析构class Animal{public:    Animal()    {        cout << "Animal的构造函数调用" << endl;    }    //利用虚析构可以解决父类指针释放对象时不干净的问题    /*virtual ~Animal()    {        cout << "Animal的析构函数调用" << endl;    }*/    //纯虚析构,需要声明也需要实现    //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象        virtual ~Animal() = 0;    //纯虚函数，不需要实现    virtual void speak() = 0;};//纯虚析构函数Animal::~Animal(){    cout << "Animal纯析构函数调用" << endl;}class Cat :public Animal{public:    Cat(string name)    {        m_Name = new string(name);    }    virtual void speak()    {        cout << "Cat的构造函数调用" << endl;        cout << *m_Name << "小猫在说话" << endl;    }    ~Cat()    {        if (m_Name != NULL)        {            cout << "Cat的析构函数调用" << endl;            delete m_Name;            m_Name = NULL;        }    }    string* m_Name;};void test01(){    Animal* animal = new Cat("Tom");    animal->speak();    /*    父类的指针在析构的时候，不会调用子类中的析构函数，    导致子类如果有堆区属性，会出现内存的泄漏情况。    解决:将父类的析构函数改为虚析构    */    delete animal;}int main(void){    test01();    system("pause");    return 0;}</code></pre><p><strong>总结</strong>:</p><ol><li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象问题</li><li>如果<a href>子类中没有堆区数据</a>，可以不写为虚析构或纯虚析构</li><li>拥有纯虚析构函数的类也属于抽象类</li></ol><h6 id="多态案例3——电脑组装"><a href="#多态案例3——电脑组装" class="headerlink" title="多态案例3——电脑组装"></a>多态案例3——电脑组装</h6><h2 id="三、进阶技巧（泛型编程-STL基础）"><a href="#三、进阶技巧（泛型编程-STL基础）" class="headerlink" title="三、进阶技巧（泛型编程+STL基础）"></a>三、进阶技巧（泛型编程+STL基础）</h2><h2 id="四、文件操作"><a href="#四、文件操作" class="headerlink" title="四、文件操作"></a>四、文件操作</h2><p>数据永久化的方式：文件和数据库。</p><p>c++中文件操作属于技术应用而不是文件操作。</p><p>c和c++主要用于开发后台服务程序，不再用于开发人机交互界面。</p><p>![image-20230801004251696](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230801004251696-16955482143567.png)</p><ul><li><p>文本数据：存放的是字符春，以<a href>行</a>为单位，每个字节都有意义，每个字节存储一个ASCII码来表示字符</p></li><li><p>二进制数据：单个字节没有意义，要几个字节作为一个整体来考虑，才有意义</p><p>使用<code>fin.read((char *)&amp;p,sizeof(Person))</code>读取二进制文件</p></li></ul><h4 id="1、实际开发中的操作"><a href="#1、实际开发中的操作" class="headerlink" title="1、实际开发中的操作"></a>1、实际开发中的操作</h4><p>在实际开发中，从兼容和语义考虑，一-般: </p><ul><li><p>以文本模式打开文本文件，用行的方法操作它;</p></li><li><p>以二进制模式打开二进制文件，用数据块的方法操作它; </p></li><li><p>以二进制模式打开文本文件和二进制文件，用数据块的方法操作它，这种情况表示不关心数据的内容。(例如复制文件和传输文件) </p></li><li><p>不要以文本模式打开3进制文件 ，也不要用行的方法操作二进制文件，可能会破坏二进制数据文件的格式，也没有必要。(因为二 进制文件中的某字节的取值可能是换行符，但它的意义并不是换行，可能是整数n个字节中的某个字节)</p></li></ul><h4 id="2、文件位置指针"><a href="#2、文件位置指针" class="headerlink" title="2、文件位置指针"></a>2、文件位置指针</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>ofstrem类中是成员函数<code>tellp()</code>;ifstream类中是成员函数<code>tellg()</code>;fstream类中两个函数都有，<a href>两者作用一样</a></p><h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p>ofstrem类中是成员函数<code>seekp()</code>;ifstream类中是成员函数<code>seekg()</code>;fstream类中两个函数都有</p><h5 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h5><p>![image-20230801144909811](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230801144909811-16955482143568.png)</p><p>数据写入是按覆盖的形式，写入后是第三行的形式。想要第二种形式，必须把原本内容后移三个字节。</p><p>![image-20230801145232477](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230801145232477-16955482143569.png)</p><h4 id="3、文件缓冲区和流状态"><a href="#3、文件缓冲区和流状态" class="headerlink" title="3、文件缓冲区和流状态"></a>3、文件缓冲区和流状态</h4><h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><p>![image-20230801172442828](E:\My Blog\Blog\source_posts\C++巩固.assets\image-20230801172442828-169554821435610.png)</p><p>在C++中，每打开一个文件，系统都自动为其分配一个缓冲区，不同的流，<a href>缓冲区是独立的</a>。程序员不需要关</p><p>输入缓冲区，只需要关注输出缓冲区即可。</p><p>在缺省模式下，只有缓冲区数据满了，才会把数据写入磁盘，但是有时会降低效率。</p><p>刷新缓冲区函数:<code>flush()</code>    不管缓冲区中有多少数据，立刻将数据写入磁盘中</p><p><code>endl</code>除了换行，还有刷新缓冲区的作用。</p><p><code>fout&lt;&lt;unitbuf</code>   设置fout输出流，在每次操作后自动刷新缓冲区</p><p><code>fout&lt;&lt;nounitbuf</code>  让fout返回到缺省的缓冲方式</p><h5 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h5><p>流状态有3个: eofbit、 badbit 和 failbit, 取值: 1-设置;或0-清除。</p><p>当三个流状成都为0时,表示一切顺利，good()成员函数返回true。</p><ul><li><p>eofbit</p><p>当<a href>输入流</a>操作到达文件未尾时，将设置eofbit.，</p><p>eof()成员函数检查流是否设置了eofbit。<code>fin.eof() == true</code></p></li><li><p>badbit<br>无法诊断的失败破坏流时，将设置badbit。(例如: 对输入流进行写入;磁盘没有剩余空间)</p><p>bad()成员函数检查流是否设置了badbit。 </p></li><li><p>failbit</p><p>当输入流操作未能读取预期的字符时，将设置failbit (非致命错误，可挽回，一般是软件错误，例如:想读取</p><p>个整数，但内容是-一个字符串;文件到了未尾) I/O失败也可能设置failbit。 </p><p>fail()成员函数检查流是否设置了failbit。 </p></li><li><p>clear()成员函数清理流状态</p></li><li><p>setstate()成员函数重置流状态</p></li></ul><h2 id="五、编程技巧"><a href="#五、编程技巧" class="headerlink" title="五、编程技巧"></a>五、编程技巧</h2><ol><li>Ctrl + D</li><li>Ctrl + Enter</li><li>if + tab  for + tab swtich + tab</li><li>alt 选中变量  Ctrl + Alt 选中</li><li>F10，F11</li><li>Ctrl + L</li><li>Ctrl + F</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="/2023/07/25/git-ru-men/"/>
      <url>/2023/07/25/git-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Git新手向"><a href="#Git新手向" class="headerlink" title="Git新手向"></a>Git新手向</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>Git是版本控制软件，而github是基于Git这个版本控制软件打造的网站。</p><p>Git的三个概念：commit提交、repository仓库、branch分支</p><p>何为版本控制软件：<a href="">仓库</a>中<a href="">多人</a>协同完成代码后提交<a href="">存档</a></p><p>目的：方便后悔，找回历史记录</p><h2 id="二、查看他人Github项目"><a href="#二、查看他人Github项目" class="headerlink" title="二、查看他人Github项目"></a>二、查看他人Github项目</h2><p>浏览他人github代码仓库时,code找到网址，然后再自己的工作文件夹中Git bash 命令<code>git clone 代码网址</code></p><ul><li>git clone   克隆项目</li><li>star   收藏</li><li>Readme.md  说明文档</li><li>LICENSE  许可证</li><li>issue  论坛                    </li></ul><h2 id="三、查找开源项目"><a href="#三、查找开源项目" class="headerlink" title="三、查找开源项目"></a>三、查找开源项目</h2><p>找开源项目的一些途径<br>• <a href="https://github.com/trending/">https://github.com/trending/</a><br>• <a href="https://github.com/521xueweihan/HelloGitHub">https://github.com/521xueweihan/HelloGitHub</a><br>• <a href="https://github.com/ruanyf/weekly">https://github.com/ruanyf/weekly</a><br>• <a href="https://www.zhihu.com/column/mm-fe">https://www.zhihu.com/column/mm-fe</a></p><p>特殊的查找资源小技巧-常用前缀后缀<br>• 找百科大全 awesome xxx<br>• 找例子 xxx sample<br>• 找空项目架子 xxx starter / xxx boilerplate<br>• 找教程  xxx tutorial</p><h2 id="四、Git操作"><a href="#四、Git操作" class="headerlink" title="四、Git操作"></a>四、Git操作</h2><p>git clone 下载下来的是仓库，有.git文件夹；download zip下载下来是单纯的文件夹</p><ul><li><p>克隆仓库：git clone &lt;git地址&gt;</p></li><li><p>初始化仓库：git init   建立.git文件夹</p></li><li><p>提交</p><p>![image-20230725115318390](E:\My Blog\Blog\source_posts\Git入门.assets\image-20230725115318390.png)</p><ul><li><p>添加文件到暂存区：git add -A</p></li><li><p>把暂存区的文件提交到仓库：git commit -m “提交信息”  </p><p>或者vscode中的源代码管理 ctrl + enter</p></li><li><p>查看提交的历史记录：git log –stat   </p><p>或者在源代码管理区查看，一次提交都对应一个哈希值</p></li></ul></li><li><p>维护项目</p><ul><li><p>工作区回滚：git checkout <filename>  </filename></p><p>相当于ctrl + z  或者源代码管理区中的更改撤回按钮</p></li><li><p>撤销最后一次提交：git reset HEAD^1    </p><p>或者源代码管理区的undo commit</p></li></ul></li><li><p>分支</p><ul><li><p>以当前分支为基础新建分支：git checkout -b <branchname>  b为build</branchname></p></li><li><p>列举所有的分支：git branch</p></li><li><p>单纯地切换到某个分支：git checkout <branchname></branchname></p></li><li><p>删掉特定的分支：git branch -D <branchname></branchname></p></li><li><p>合并分支：git merge <branchname>  </branchname></p><p>git merge –abort  放弃本次合并</p></li></ul></li><li><p>Git远程仓库</p><ul><li>推送当前分支最新的提交到远程：git push </li><li>拉取远程分支最新的提交到本地：git pull</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门</title>
      <link href="/2023/07/11/python-ru-men/"/>
      <url>/2023/07/11/python-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础入门"><a href="#Python基础入门" class="headerlink" title="Python基础入门"></a>Python基础入门</h1><blockquote><p>笔记文档：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p></blockquote><p>python是一门解释型语言，先用解释器翻译为字节码，然后再由编译器编译为机器码，计算机才可以执行。（一般.exe文件就是机器码）</p><h2 id="创始人"><a href="#创始人" class="headerlink" title="创始人"></a>创始人</h2><p>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p><p>“*Python的创始人为<a href="">荷兰人</a>吉多·范罗苏姆(Guido van Rossum)*“</p><p>Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用<a href="">4</a>个空格的缩进。</p><p>在Python文件中，前面两行建议添加下面两行注释：</p><p>#!/usr/bin/env python3</p><p># -<em>- coding: utf-8 -</em>-</p><p>第一行注释，是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释，是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p><ul><li><p>0开头代表八进制数，0x开头代表16进制</p></li><li><p>很长的数可以用_分开，比如10_000_000_000；0xa1b2_c3d4</p></li><li><p>Python的整数，浮点数没有大小限制</p></li><li><p>浮点数可以这样表示：把10用e替代，1.23x10^9就是<code>1.23e9</code>或者<code>12.3e8</code>0.000012可以写成<code>1.2e-5</code></p></li><li><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p></li><li><p>如果字符串内部既包含<code>'</code>又包含<code>"</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p><pre class=" language-python"><code class="language-python"><span class="token string">'I\'m \"OK\"!'</span></code></pre><p>表示的字符串内容是：</p><pre class=" language-python"><code class="language-python">I'm <span class="token string">"OK"</span>!</code></pre></li><li><p>Python还允许用<code>r''</code>表示<code>''</code>内部的字符串默认不转义</p></li><li><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#格式化字符串%  和占位符 %s %d</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%2d-%02d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%.2f'</span> <span class="token operator">%</span> <span class="token number">3.1415926</span><span class="token punctuation">)</span>format格式化字符串<span class="token string">'Hello, {0}, 成绩提升了 {1:.1f}%'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span> <span class="token number">17.125</span><span class="token punctuation">)</span><span class="token string">'Hello, 小明, 成绩提升了 17.1%'</span></code></pre><p>f-string</p><p>最后一种格式化字符串的方法是使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>{xxx}</code>，就会以对应的变量替换：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> <span class="token number">2.5</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token operator">*</span> r <span class="token operator">**</span> <span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The area of a circle with radius {r} is {s:.2f}'</span><span class="token punctuation">)</span>The area of a circle <span class="token keyword">with</span> radius <span class="token number">2.5</span> <span class="token keyword">is</span> <span class="token number">19.62</span></code></pre><p>上述代码中，<code>{r}</code>被变量<code>r</code>的值替换，<code>{s:.2f}</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>{s:.2f}</code>的替换结果是<code>19.62</code>。</p></li><li><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>'''...'''</code>的格式表示多行内容</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token triple-quoted-string string">'''line1line2line3'''</span><span class="token punctuation">)</span>输出：line1line2line3</code></pre></li><li><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p></li><li><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p></li><li><p><a href="">变量</a>的概念基本上和初中代数的方程变量是一致的</p></li><li><p><code>=</code>是赋值语句</p><p>![py-var-code-1](E:\My Blog\Blog\source_posts\Python入门.assets\0.png)</p><p>b = a后：</p><p>![py-var-code-2](E:\My Blog\Blog\source_posts\Python入门.assets\0-16623065203103.png)</p></li><li><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，数据类型可以随时改变</p></li><li><p>除法有 <strong>/ 和</strong>// **地板除法两种。</p></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><a href=""><strong>集合推导式：</strong></a></li></ul><pre class=" language-python"><code class="language-python"><span class="token punctuation">{</span>s <span class="token keyword">for</span> s <span class="token keyword">in</span> <span class="token string">"fishc.com.cn"</span><span class="token punctuation">}</span></code></pre><blockquote><p>例子(这条格式快捷键 &gt; )</p></blockquote><p>![img](E:\My Blog\Blog\source_posts\Python入门.assets\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YiY57uP57qs6ICB5biI,size_20,color_FFFFFF,t_70,g_se,x_16.png)</p><blockquote><p>说明文档中函数（*others）支持多个参数；函数（other）只支持一个参数。</p></blockquote><p>可哈希的对象才能作为字典的键</p><p>可变的容器是不可哈希的；集合是可变的容器所以不可hash（）；frozenset是不变的容器，可哈希，可嵌套。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><strong>format：</strong>print( f’{sample}’)  把sample作为字符串输出</p></li><li><p>参数分为形参和实参</p></li><li><p>位置参数和关键字参数（参数多的时候用不混乱：(a=1;b=2)）.两个参数一起用时位置参数必须在关键字参数前面</p></li><li><p>默认参数即在定义参数时给了默认值，调用函数时如果没有这个参数则用默认值，有则覆盖默认值。默认参数放后边</p></li><li><p>help（）查看函数文档时候函数原型中（/），/左边的参数必须是位置参数，/右边随便</p><p>参数定义中<a href="">*</a>左边可以随便，右边必须是关键字参数：这个星号其实就是一个匿名的收集参数，后面不加参数名的话会被一起收进去</p></li><li><p>**<a href="">收集参数</a>*<em>：在形参的前面加一个星号（</em>）来表示，将多个参数打包进一个元组：tuple，后边必须是关键字参数，不然会被打包。比如format函数就是两种收集参数都有。</p><blockquote><p>两个星号收集参数是打包成字典，参数用a=1；b=2的键值对来表示</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token operator">*</span>b<span class="token punctuation">,</span><span class="token operator">**</span>c<span class="token punctuation">)</span>myfunc<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>x<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#综合</span></code></pre></li><li><p>函数return多个值其实是用元组进行打包，也可以拿来解包</p></li><li><p>解包参数：一个*把元组解包传入函数；**把字典解包传入函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span>    args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>myfunc<span class="token punctuation">(</span><span class="token operator">*</span>argc<span class="token punctuation">)</span>kwargs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>myfunc<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span></code></pre></li><li><p>作用域：</p><p>1.局部作用域：在函数中局部变量会覆盖全局变量</p><p>2.全局作用域</p></li><li><p>global语句：声明变量为全局变量</p></li><li><p>嵌套函数：只能在该函数中调用，外部无法访问</p></li><li><p>nonlocal语句：修改嵌套上一层的函数作用域变量；global则是修改全局变量</p></li><li><p>LEGB规则：local&lt;-enclose(嵌套外层)&lt;-global&lt;-build(内置作用域)</p><p>内置作用域就是python自带的关键字变量 比如str  起个同名的变量则覆盖原来的str</p><p><a href="">就近原则</a></p></li><li><p>闭包：</p><p>对于嵌套函数来说，嵌套外层作用域变量会保留下来，不会想局部作用域那样调用完就消失。*<a href="">内层函数能够记住外层函数作用域</a>*</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">funcA</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">funcB</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>​    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token operator">*</span>a<span class="token punctuation">)</span>  <span class="token keyword">return</span> funcBstate <span class="token operator">=</span> funcA<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#&lt;function funcA.&lt;locals>.funcB at 0x0000023DEE1C0EE0>  state得到得是funcB函数的一个引用。</span><span class="token keyword">print</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>state<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#a参数已经被内层函数funcB记住了</span><span class="token number">20</span>state<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token number">30</span></code></pre></li><li><p>装饰器：</p><p>函数名是函数引用；函数名后加一对小括号是对函数的调用</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">report</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    func<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>装饰器作用：拿函数当参数，做闭包，把函数参数传入嵌套函数内部</p><p><a href=""><strong>在不修改原来函数代码的前提下增加功能</strong></a></p><p>语法：@嵌套函数名字            （即附加的功能函数）</p><p> 比如myfunc = timemaster(mufunc)  等价于 @timemaster</p><p>然后正常调用函数即可</p><p><a href="">语法糖下边是所参入函数的声明,所以定义的函数被装饰了</a></p></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add1</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>            <span class="token keyword">return</span> x<span class="token operator">+</span>x        <span class="token keyword">return</span> inner    <span class="token keyword">return</span> add<span class="token keyword">def</span> <span class="token function">cube</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token operator">*</span>x    <span class="token keyword">return</span> inner<span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>x    <span class="token keyword">return</span> inner@add1<span class="token punctuation">(</span>msg <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">)</span>@cube@square<span class="token comment" spellcheck="true">#从下往上调用装饰器  2+2  4*4*4  64+64</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token comment" spellcheck="true">##语法糖之后就可以调用函数了 </span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>装饰器带参数实质是多添加一次调用，两层嵌套函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">logger</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">timemaster</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            func<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> innner    <span class="token keyword">return</span> timemaster@logger<span class="token punctuation">(</span>msg <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">)</span></code></pre><ul><li>lambda表达式：  <a href="">匿名函数</a>(不需要考虑给<a href="">过于简单</a>的函数起名了)  一行流代码</li></ul><p>​    语法： lambda arg1， arg2, arg3, ……argN : expression</p><pre class=" language-python"><code class="language-python">squareY <span class="token operator">=</span> <span class="token keyword">lambda</span> y<span class="token punctuation">:</span> y<span class="token operator">*</span>ysquareY<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token number">9</span><span class="token comment" spellcheck="true">#squareY是函数的调用</span></code></pre><p>​    lambda是一个表达式，可以放在常规def函数放不到的地方，比如列表里</p><pre class=" language-python"><code class="language-python">y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span>x<span class="token operator">*</span>x <span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">4</span>mapped <span class="token operator">=</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> ord<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'hello wukun!'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#map函数第一个参数是函数的调用 第二个参数是调用函数内的参数</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>mapped<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">118</span><span class="token punctuation">,</span> <span class="token number">118</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">129</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">117</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">]</span>filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>filter<span class="token punctuation">(</span>function<span class="token punctuation">,</span>iterable<span class="token punctuation">)</span> function <span class="token operator">-</span><span class="token operator">></span> 判断条件iterable <span class="token operator">-</span><span class="token operator">></span> 可迭代对象</code></pre><ul><li><p>生成器</p><p>让函数在退出之后还能保留原来状态：闭包或者全局变量</p><p>还可以用生成器（相当于制作机器，每调用一次生成一个数据，而并且保留状态）：用yield替代return</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> counter <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span><span class="token number">0</span>     <span class="token keyword">while</span> i <span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">:</span>              <span class="token keyword">yield</span> i              i <span class="token operator">+=</span><span class="token number">1</span> <span class="token comment" spellcheck="true">##再次调用counter生成器时，会从 i+=1 开始</span></code></pre></li></ul><p>​      特殊的迭代器，不走回头路，还可以支持next（）函数，不支持下标索引。</p><p>​      生成器表达式：</p><p>​        </p><pre class=" language-python"><code class="language-python">t <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> t<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token number">0</span><span class="token number">1</span><span class="token number">4</span><span class="token number">9</span><span class="token number">16</span><span class="token number">25</span><span class="token number">36</span><span class="token number">49</span><span class="token number">64</span><span class="token number">81</span></code></pre><ul><li><p>递归</p><p>迭代是while循环类似，而递归是循环调用函数本身。汉诺塔的应用是递归的最佳例子：找到关键循环和形参实参的区别调用。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>                   <span class="token comment" spellcheck="true">#定义汉诺塔函数,参数n是圆盘数，A、B、C是3根柱</span>   <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                           <span class="token comment" spellcheck="true">#判断圆盘数，如果等于1，递归条件</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token string">'-->'</span><span class="token punctuation">,</span>C<span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 直接将A柱上的圆盘移动到C柱上</span>   <span class="token keyword">else</span><span class="token punctuation">:</span>                              <span class="token comment" spellcheck="true">#否则，进行递归移动</span>      hanoi<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>A<span class="token punctuation">,</span>C<span class="token punctuation">,</span>B<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#递归将A柱最上方的n-1个盘子落在B柱</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token string">'-->'</span><span class="token punctuation">,</span>C<span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出将A柱上的圆盘移动到C柱上,也就是将A柱的最小面盘子落在C柱</span>      hanoi<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>B<span class="token punctuation">,</span>A<span class="token punctuation">,</span>C<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">#递归将B柱上的n-1个盘子，落在C柱</span>hanoi<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#调用函数</span></code></pre></li><li><p>函数文档说明：</p></li><li><p>高阶函数：一个函数接收另一个函数，将函数作为参数使用；python库中有许多集成的高阶函数模块：functools ，可以自己调用</p><p>例如：functools.reduce(a,b)</p></li></ul><ul><li><p>永久储存：把代码储存在硬盘中</p><p>1、操作文件</p><p>使用f = open（）；其中第一个参数：‘文件路径’，第二个参数：‘操作类型: w.  r   ’,返回文件对象</p><p><a href="">w操作类型是先把文件清空，再写入内容</a></p><p>文件指针类似于文件内存位置：f.read()</p><p>2、处理路径</p><p>pathlib模块  from pathlib import Path  </p><p>p = Path(文件路径名)</p><p>避免字符串重复处理转义 <a href="/">/</a> 的问题</p><p>.. 为上一级路径， ./ 为当前路径  .为当前路径</p><p>3、with语句和上下文管理器</p><p>不需要手动关闭文件 ,<a href="">确保资源的释放</a>：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#常规操作文件流程</span>f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'fichc.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'I  love fichc.com'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#上下文管理器</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'fishc.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'I love fishc.com'</span><span class="token punctuation">)</span></code></pre><p>pickle模块：将python对象序列化（将python对象（变量，列表，字典）转换成二进制字节流）</p><p>以pkl后缀，</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'ii.pkl'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">##wb二进制写入模式</span>    pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 存入</span>    x<span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token comment" spellcheck="true">##读取</span></code></pre><blockquote><p>print函数的作用是打印输出内容，它的sep和end参数可以让我们的打印更具有个性化。</p><p>seq：用来间隔多个对象，默认值是一个空格。也可以输入特定的值（符号、数字、中文都可）来间隔内容。<br>end：用来设定以什么结尾，默认值是换行符”\n”。也可以输入其他值来结尾</p></blockquote></li><li><p>异常处理</p><p>捕捉异常使用try/except语句</p><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token keyword">except</span> ZeroDivisionError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'没有出错！'</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'出没出错都要执行这条语句'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##检测多个类型错误，用tuple</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>    <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'fishc'</span><span class="token keyword">except</span> <span class="token punctuation">(</span>ZeroDivisionError<span class="token punctuation">,</span>TypeError <span class="token punctuation">,</span> ValueError<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">##如果是这些类型错误则执行以下语句</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'出错了！！'</span><span class="token punctuation">)</span></code></pre><p>自己主动<a href="">抛出异常</a>（Python中有的异常类型）：</p><p>1、raise A异常和raise A异常 from B异常</p><p><code>raise ValueError('这是一个数值错误！,由除以0的错误产生的')</code> <code>from ZeroDivisionError</code></p><p>利用raise可以用出goto效果：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> true<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'跳过'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'跳过'</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'raise抛出异常后直接跳到这条语句了'</span><span class="token punctuation">)</span></code></pre><p>2、assert  只会产生AssertionError, 类似一个断点，便于调试</p><p><code>a = 1</code></p><p><code>assert a ==1</code></p><p><code>assert a !=1</code></p></li></ul><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程三大基本特征：封装、继承、多态</p><p>面向对象也是一种代码封装的方法。</p><p>$对象 = 属性（特征）+方法（能做的事）$</p><blockquote><p>类是“一种摸具”，可以批量生产对象。例如人类是类，一个特定的人是对象。</p></blockquote><ul><li><p>封装：创建对象之前，通过类将相关属性和方法打包到一起，然后通过类生成相应的对象： <code>c = Turtle()</code></p><p>类中方法默认的第一个参数‘self’是实例化对象本身，目的是让python清楚是哪个实例对象在调用方法</p></li><li><p>继承：</p><p><code>c = B(A)</code>, 类B继承类A，父类已有属性和方法重在子类中写会<a href="">覆盖</a></p><p>多重继承： <code>class C(A,B)</code>,实例化后属性和方法会先继承A类的，从左至右顺序(<a href="">MRO</a>,方法解析顺序)。</p><p>组合：将多个实例化对象放在类中，比如一个花园摸具中应该有狗，猫，鱼等。</p><blockquote><p>tip: python默认所有类继承于object</p></blockquote></li><li><p>绑定</p><p>self起到的作用是：将实例对象与类的方法绑定</p><blockquote><p>在实例中，除了类的方法可以共享外，实例的属性可以是自己的</p></blockquote><p>通过类中的方法设置属于对象自己的属性，可以通过绑定：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">set_value</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> value    </code></pre><p>这段代码其实相当于实例化后<code>a.x = value</code></p><p>实例化对象是没有属于自己的属性的，只会从生成它的类中去查询，但当自己实例化属性后就拥有了，</p><p>类的属性是所有对象共享的，类中的属性最好不要随意更改，牵一发而动全身</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    x<span class="token operator">=</span><span class="token number">1</span>a <span class="token operator">=</span>A<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">{</span><span class="token punctuation">}</span>a<span class="token punctuation">.</span>x <span class="token operator">=</span><span class="token number">90</span>a<span class="token punctuation">.</span>x<span class="token number">90</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span></code></pre><p>tip: 类和对象的属性通过<a href="">字典</a>,对象中的<code>__dict__</code>属性保存。</p><p><code>pass</code>为占位语句，最小的类中只有pass，空类生成的实例可以当作字典</p></li><li><p>构造函数：在类中定义构造函数以实现实例个性化</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x        self<span class="token punctuation">.</span>y <span class="token operator">=</span> y   <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>x <span class="token operator">+</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##相当于实例化时可以传参数了</span></code></pre><p>钻石（菱形）继承问题：若自己两个父类的父类是同一个，那么将调用”爷“类两次</p><p>通过<code>super（）</code>函数解决查找父类方法重复的问题，<code>super().__init__()</code></p></li><li><p>Mixin:</p><p>它是一种<a href="">设计模式</a>（利用编程语言已有的特性针对面对对象开发过程中反复出现的问题而设计出来的解决方案）</p><p><a href="">super()函数严重依赖MRO顺序</a>，也会寻找同等继承关系的类，再去寻找上一级父类</p><p>可以通过多继承添加功能，在添加功能时（mixin）时也可以使用super（）函数去寻找同等继承关系类的方法</p></li><li><p>多态</p><p>是指一个运算符，函数或者对象在不同的场景下有不同的作用效果，比如<code>3+3</code>与<code>'fishc'+'fishc'</code>，两个<code>+</code>号的作用不同作用，又如<code>len()</code></p><p>多个子类继承同一个父类，但又重写了构造函数或者方法，这就是多态的体现。</p><p>当函数接收不同的参数（继承一个父类，但是重写方法或者构造函数了）有不同的输出，这就具有多态性了</p></li><li><p>私有变量</p><p>通过某种手段使对象中的属性和方法不被外部访问</p><p>在python中是在变量前加两个下划线作为“私有变量”:<code>__x</code>，不能直接访问和修改，只能通过接口（内部定义函数来修改），还可以通过c._C__x</p><blockquote><p>在python中私有变量其实是通过改名实现的，<code>__x</code>变为了<code>_C__x</code></p></blockquote><p>私有方法也是如此操作，私有变量，私有方法名字改编是在类实例化对象的时候。</p><p>单个下横线开头的变量 <code>_x</code>通常是仅供内部使用的变量，不要随意访问和试图修改</p><p>实例化对象可以<a href="">动态添加属性</a>，是因为这个字典的机制，可以通过<code>c.__dict__['x']= 666</code>添加属性</p><p>字典除了浪费空间外，其他都是优点，针对这一缺陷，python出了类属性<code>__slots__ = [‘x’,‘y’]</code>,这样限制了实例化对象只能拥有x,y两个属性，构造函数个性化多参数也不行，限制死了。</p><p>tip:继承自父类的<code>__slots__</code>不会在子类生效 </p></li><li><p>魔法方法：实现对象的个性化定制，作用是拦截，重写运算符</p><p>例如<code>__init__()</code>在对象实例化时就自动调用从而实现了对象的个性化定制</p><p>1<code>__new()__(cls[])</code>,在<code>__init__(self)</code>之前，是第一个调用的魔法方法，用于创建对象，返回实例化对象传递给<code>__init__()</code></p><p>2.<code>__del__(self)</code>,在对象没有被引用后启动，例如:</p><pre class=" language-python"><code class="language-python">c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">del</span> c<span class="token comment" spellcheck="true">##此时会执行__del__()</span>c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> c<span class="token keyword">del</span> c<span class="token comment" spellcheck="true">##此时d还在引用c对象，所以不会执行__del__()</span></code></pre><p>3.运算相关的魔法方法</p><ul><li><p>运算魔法方法：例如<code>__add__(self,other)</code>,通过重写覆盖，使得两个字符串之间相加结果不是拼接，而是返回字符个数之和。</p><p><code>s1+s2</code>实际是<code>s1.add(s2)</code></p></li><li><p>反运算魔法方法：<code>__radd__(self,other)</code><a href="">,两个基于不同类的对象</a>进行相加运算时，若左边对象的add魔法方法返回NotImplemented关键字，则会去寻找右边对象的<code>__radd__(self,other)</code>方法。</p></li></ul></li></ul><ul><li><p>赋值运算魔法方法：例如<code>__iadd__(self,other)</code>实现的就是+=运算符,若增强运算符左侧的对象没有实现相应的魔法方法，则python就会退而求其次，寻找<code>__add__(self,other)</code>、<code>__radd__(self,other)</code>来实现</p><p>内置函数魔法方法：例如<code>__int__(self)</code></p></li><li><p>位运算魔法方法：按位与<code>&amp;</code>，按位或<code>|</code>,按位非<code>~</code>，按位异或^,左移&lt;&lt;,右移&gt;&gt;</p></li><li><p><code>__index__(self)</code>,在对象作为索引值时会发生拦截，触发。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__index__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'触发'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">3</span>c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token string">'fishc'</span>s<span class="token punctuation">[</span>c<span class="token punctuation">]</span>h</code></pre></li></ul><p>  4.属性访问相关的魔法方法 </p><p>  <code>hasattr(c,'name')</code>判断c对象中是否有name这个属性</p><p>  <code>getattr(c,'name')</code>得到对象属性的值，对应魔法方法为<code>__getattribute__(self,attrname)</code>,<code>__getattr__(self,attrname)</code>对应是当寻找一个不存在的属性时触发</p><p>  <code>setattr(c,'age',10)</code>设置对象属性的值，对应魔法方法为<code>__setattribute__(self,attrname,value)</code></p><blockquote><p>进行魔法方法<code>_setattribute__(self,attrname,value)</code>重写时若有再次赋值<code>self.name = name</code>,则会无限递归属性赋值魔法方法，解决办法：使用对象属性<code>self.__dict__[attrname] = value</code>避免。</p><p>同理,重写<code>__delattr__(name)</code>时，使用<code>del self.__dict__[name]</code>避免递归</p></blockquote><p>  <code>delattr(c,'name')</code>删除对象属性</p><p>  5.索引、切片、迭代协议</p><p>  当对象被索引时用到的魔法方法为<code>__getitem__(self,index)</code>，for循环函数也会索引对象</p><p>  切片函数<code>slice(none:none:4)</code>,开头和结尾为默认，每间隔4提取一个字符</p><p>  迭代器中有<code>__iter__(self)</code>和<code>__next__(self)</code>魔法方法，实现的next()函数是<a href="">真正实现迭代</a>操作的</p><blockquote><p>如果一个对象有<code>__iter__(self)</code>则为可迭代对象，如果可迭代对象有<code>__next__(self)</code>则为可迭代器</p><p>list是个可迭代对象，没有next魔法方法，所以不是迭代器</p></blockquote><p>  6.代偿</p><p>  <code>__contains__(self,item)</code>为in 和not in 运算符的魔法方法，用于实现成员的检测</p><p>  如果使用了in 和not in 运算符，而对象中没有<code>__contains__(self,item)</code>，则会使用<code>__iter__(self)</code>和<code>__next__(self)</code><a href="">代偿</a>，如果再没有，则会寻找<code>__getitem__(self,index)</code></p><blockquote><p>不希望哪个魔法生效的话，直接赋值为None，例如<code>__contains__ = None</code>,则会产生代偿时限，不会再去继续寻找代偿的魔法方法</p></blockquote><p>  7.</p><p>  <code>__call__(self,[,args])</code>对应当是实例化对象作为函数使用时调用的魔法方法。</p><p>  <code>eval()</code>函数作用是将参数去引号后执行,<code>repr()</code>是对参数加引号</p><p>  对于<code>__str__(self)</code>和<code>__repr__(self)</code>  repr魔法方法适用范围更广。print()调用的是<code>__str__(self)</code>魔法方法，直接打印调用的是<code>__repr__(self)</code> </p><p>  8.property函数</p><p>  与str()函数一样作为python内置函数，返回property属性对象</p><p>  作用是:负责把一个方法当作属性进行使用(<a href="">对应属性操作中的访问,修改和删除</a>，拦截原来属性的访问，修改和删除操作),这样做可以简化代码</p><p>  定义property属性有两种方式:装饰器方式和类属性方式   x = property(属性的获取,设置,删除)</p><ul><li><p>类方法和静态方法</p><p>类方法和静态方法都属于类，不用实例化对象都可以使用。</p><p>类方法：专门用于绑定类的方法，用装饰器@classmethod实现，比如可以了解这个类实例化了多少对象</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">:</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">funA</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span>：        <span class="token keyword">print</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span></code></pre><p>静态方法：可以放在类中的方法，用@staticmethod实现，可以不用绑定参数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">:</span>    @stasicmethod    <span class="token keyword">def</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>描述符</p><p>定义：只要实现了属性的三大操作方法（访问，修改和删除）的类就叫做描述符，就是函数当属性使用。</p><p>访问：<code>__get__(self,instance,owner)</code></p><p>修改：<code>__set__(self,instance,value)</code></p><p>删除：<code>__delete__(self,instance)</code></p><blockquote><p>其中self对应的是描述符这个类的实例化对象，instance对应的是被描述符拦截的<a href="">属性</a>所在的类的实例化对象，owner对应的是被描述符拦截的属性所在的类</p></blockquote><p>描述符只能作用在类属性，不能作用在实例化对象的属性,如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>instance<span class="token punctuation">,</span>owner<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"get_"</span><span class="token punctuation">)</span>                <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x  <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>非数据描述符：实现<code>__get___</code>,数据描述符：实现<code>__set__,__delete__</code>之一</p><p>当发生属性访问时，<a href="">拦截顺序</a>是数据描述符，实例对象属性，非数据描述符，类属性，其中魔法方法<code>__getattribute__(self,name)</code>优先级最高</p><p>描述符在python3.6中最新添加了一个魔法方法：<code>__set_name__(self,owner,name)</code>,可以间接作用在实例化对象的属性</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__set_name__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>owner<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>instance<span class="token punctuation">,</span>owner<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'get_'</span><span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__set__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>instance<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>__dict__<span class="token punctuation">[</span>self<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> value        <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>    c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>xget_c<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">250</span>setc<span class="token punctuation">.</span>__dict__<span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">250</span><span class="token punctuation">}</span>c<span class="token punctuation">.</span>xget_</code></pre></li><li><p>函数，方法，静态方法，类方法</p><p>在python中函数就是一个非数据描述符</p></li><li><p>类装饰器</p><p>作用就是在类实例化对象之前进行拦截</p></li><li><p>type（）函数和<code>__init__subclass__</code></p><p>type（）查看对象的类型，所定义的类的类型起源与type类型，类是由type创造而来的。</p><p><code>__init__subclass__</code>魔法方法便于父类管理子类，当继承父类时会拦截覆盖相关的属性</p></li><li><p>元类及其应用</p><p>元类是创造类的模板，所有的元类都继承于type，元类就是在type和类之间架上了一座桥梁。</p><p>元类中的<code>__new__</code>魔法方法是在定义完继承于该元类时触发的，而定义的类的<code>__new__</code>方法是在实例化对象时才触发。</p><p>应用一：给所有定义的类添加属性</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>mcls<span class="token punctuation">,</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>        attrs<span class="token punctuation">[</span><span class="token string">'father'</span><span class="token punctuation">]</span> <span class="token operator">=</span> fishc        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>mcls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>fatherfishcd<span class="token punctuation">.</span>fatherfishc      </code></pre><p>应用二：对类名的规范做限制</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> name<span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"类名字的首个字母必须大写！"</span><span class="token punctuation">)</span>        type<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span>        <span class="token keyword">class</span> <span class="token class-name">myclass</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;pyshell#12>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token keyword">class</span> <span class="token class-name">myclass</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;pyshell#10>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __init__    <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"类名字的首个字母必须大写！"</span><span class="token punctuation">)</span>TypeError<span class="token punctuation">:</span> 类名字的首个字母必须大写！</code></pre><p>应用三：修改对象的属性值</p><blockquote><p>当类实例化时都会去调用call魔法方法，相当于引用函数c = C()</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_args <span class="token operator">=</span> <span class="token punctuation">[</span>each<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> each <span class="token keyword">in</span> args <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>each <span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__call__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>new_args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> metaC<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> xc <span class="token operator">=</span>C<span class="token punctuation">(</span><span class="token string">"fishc"</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>x<span class="token string">'FISHC'</span></code></pre><p>应用四：限制对象实例化时传参的方式</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> args<span class="token punctuation">:</span>            <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"仅支持关键字参数传参"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__call__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>new_args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span></code></pre><p>应用五：干预类的实例化</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">metaC</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">"不支持实例化对象"</span><span class="token punctuation">)</span></code></pre><p>应用六：只允许实例化一个对象</p></li><li><p>抽象基类</p><p>比如：“水果类”</p><p>特点：不能被直接实例化，只能继承使用；<a href="">子类必须实现抽象基类定义的抽象方法</a>（即重新定义覆盖抽象方法），否则不能被实例化。</p><p>可以导入abc模块来对一个类作为抽象基类。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> abc <span class="token keyword">import</span> ABCMeta<span class="token punctuation">,</span>abstractmethod<span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">(</span>metaclass <span class="token operator">=</span> ABCMeta<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    @abstractmethod    <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span> </code></pre></li><li><p>写代码的精髓：不要重复造轮子。</p></li></ul><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>python中最高级的代码的打包手段，使得一个或者多个源代码文件可以被其他程序重复使用。</p><ul><li><p>the latest的名字冲突会覆盖</p></li><li><p>模块在导入过程中会从头至尾执行模块中的语句。<code>if '__name__' == '__main__'</code>语句就是用来判断该文件是否为主文件来执行。若该文件被作为模块引用，则<code>__name__</code>变为了文件名</p></li><li><p>包</p><p>支持把源文件分类储存到不同的文件夹中。用<code>.</code>号将包与模块分开，例如<code>Test.test1</code></p><p>可以编写包中的<code>__init__.py</code>源文件(相当于<a href="">构造文件</a>)对包初始化进行特定的操作。</p><p>源文件中的<code>__all__</code>属性可以限制<a href="">from…. import  *</a>语句所引用的内容</p><blockquote><p>对于包来说，没有定义<code>__all__</code>属性，则from…. import  *语句将不导入包中的任何模块</p><p>对于模块来说，没有定义<code>__all__</code>属性，则from…. import  *语句将不导入模块中的任何东西</p></blockquote></li><li><p>与全世界分享代码</p><p>将程序发布到Pypi（python package index），python包的索引仓库。pip工具在命令行窗口可以下载Pypi的第三方模块包并安装。</p></li></ul><p>==过完基础，撒花！！！==</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白教小白之博客搭建~</title>
      <link href="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/"/>
      <url>/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>​        跟着B站评论区大佬的博客学了两三天，自己也是终于把个人博客的大致框架搭了起来，踩过不少坑。然后想着自己可以在第一篇博客上把搭建的过程分享出来。当然哈，自己是个纯小白，八分主观，两分运气，如有不足之处请见谅。</p><h2 id="二、博客环境搭建"><a href="#二、博客环境搭建" class="headerlink" title="二、博客环境搭建"></a>二、博客环境搭建</h2><p>​        有挺多用来写博客的框架，比如WordPress、Jekyll 、Hugo、Django 、Hexo ，我选择的是Hexo，其是基于node.js制作的一个博客工具，赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，快速、简洁且高效，是搭建博客的首选框架。对于服务器的选择，Hexo+Github是上手的最佳方式。</p><h3 id="2-1-下载Node-js与Git"><a href="#2-1-下载Node-js与Git" class="headerlink" title="2.1.下载Node.js与Git"></a>2.1.下载Node.js与Git</h3><p>​        首先去Node.js与Git的官网，根据自己的电脑系统选择对应的版本进行下载和安装。安装位置最好选择在C盘以外。</p><h3 id="2-2Node-js的安装"><a href="#2-2Node-js的安装" class="headerlink" title="2.2Node.js的安装"></a>2.2Node.js的安装</h3><p>​    官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><ul><li><p>node.js默认安装即可，终端输入node -v 查看是否安装成功。</p><blockquote><p> <strong>注意： 如果执行 node -v 报错的话，那么手动将 Node.js 的安装路径添加到环境变量中</strong>。</p><p> <strong>添加环境变量参考：</strong><a href="https://www.cnblogs.com/ldq678/p/13287924.html">https://www.cnblogs.com/ldq678/p/13287924.html</a></p></blockquote></li><li><p>cnpm工具安装(npm国内下载速度不太行，选用淘宝镜像源加速)</p><p>终端输入<strong>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></strong>j进行安装。</p><p>终端输入cnpm -v查看是否安装成功。</p></li></ul><h3 id="2-3Git的安装"><a href="#2-3Git的安装" class="headerlink" title="2.3Git的安装"></a>2.3Git的安装</h3><p>​    官网：<a href="https://nodejs.org/en/">https://git-for-windows.github.io/</a></p><ul><li>默认安装即可，终端输入git -v 查看是否安装成功</li></ul><h3 id="2-4Hexo的安装"><a href="#2-4Hexo的安装" class="headerlink" title="2.4Hexo的安装"></a>2.4Hexo的安装</h3><p>​    前面Git和Node.js安装好后，就可以安装hexo了。</p><ul><li>安装指令：<strong>cnpm install -g hexo-cli</strong><br>依旧用hexo -v查看一下版本至此就全部安装完了。</li></ul><h2 id="三、博客推送GitHub"><a href="#三、博客推送GitHub" class="headerlink" title="三、博客推送GitHub"></a>三、博客推送GitHub</h2><p>​        自己将博客编写完成后，需要借助GitHub的服务器发布到网上。首先是github账户的注册，应该较为简单。</p><h3 id="3-1Git-的配置"><a href="#3-1Git-的配置" class="headerlink" title="3.1Git 的配置"></a>3.1Git 的配置</h3><p>​        在桌面点击鼠标右键，点击 Git Bash Here，然后分别输入下面的两个命令，并回车。</p><pre class=" language-none"><code class="language-none">git config --global user.name "此处填写你注册时的用户名"git config --global user.email "此处填写你注册时的邮箱"# 一般只要不报错，可以跳过下面寻找.gitconfig文件</code></pre><h3 id="3-2Github-的配置"><a href="#3-2Github-的配置" class="headerlink" title="3.2Github 的配置"></a>3.2Github 的配置</h3><p><strong>创建：</strong></p><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><p><strong>注意：</strong></p><ul><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：username.github.io，其中username是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</li><li>创建页面如下：</li></ul><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/1.jpg" alt="img"></p><ul><li><p><strong>配置SSH 免密登录</strong></p><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><p>**简单的来说就是给予你当前电脑访问你GitHub 仓库的权限 **</p><p><strong>操作步骤：</strong></p></li></ul><ol><li><p>在 git bash here 中创建一个ssh密钥</p><p>指令：<code>cd ~/.ssh</code></p><p>如果本地有的话，它会自动进入到了ssh目录下；</p><p> 若没有则创建： <code>ssh-keygen -t rsa -C "邮箱"</code> 此处邮箱填写自己的邮箱</p><p>然后enter三连</p><p>生成两个文件： id_rsa id_rsa.pub 存放在 C:\Users\admin.ssh 文件夹下</p><p><strong>注意：pub文件放置的，就是我们的公开的ssh码，也是给管理员这个ssh，让他来添加</strong></p></li><li><p>在GitHub 或者 Gitee 上添加 SSH key</p></li></ol><p>​        Title：随意填写</p><p>​        Key：将本地的id_rsa.pub文件用记事本打开，复制全部内容粘贴到GitHub 仓库的SSH Keys 位置</p><p>​        如下图所示：</p><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/2.jpg" alt="img"></p><p><strong>至此，全部环境均已搭建好，接下来就是博客的编写和上传了</strong></p><h3 id="3-3博客的初始化"><a href="#3-3博客的初始化" class="headerlink" title="3.3博客的初始化"></a>3.3博客的初始化</h3><ol><li><p>在电脑的某个地方新建一个名为HexoData的文件夹（名字可以随便取），这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p></li><li><p>在该文件夹下右键打开 Git Bash</p><p>并依次执行以下命令</p><p><code>hexo init</code> 初始化命令，hexo会自动下载一些文件到这个目录，包括node_modules等</p><p><code>hexo g</code> 生成命令</p><p><code>hexo s</code> 启动服务</p><p><strong>说明：</strong><code>hexo s</code> 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，说明博客初始化以及成功！</p><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/4.jpeg" alt="img"></p><p>很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，</p><p>因为4000这个端口太常见了， 只需要关闭4000端口并重新启动即可</p><p><strong>到此博客的初始化便完成了，此时你可以本地开启服务并访问，下一步便是推送到GitHub 上！</strong></p></li></ol><h3 id="3-4推送至Github"><a href="#3-4推送至Github" class="headerlink" title="3.4推送至Github"></a>3.4推送至Github</h3><ul><li><p>第一步：在自己定义的博客目录下安装 hexo-deployer-git 插件 （git bash here 处安装）</p><p>命令：<code>npm install hexo-deployer-git --save</code></p><p>说明：必须安装，否则执行hexo d 的话会报错</p><p><strong>新建自己定义的博客目录完成后，指定文件夹目录下有：</strong></p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul></li><li><p>第二步：编辑博客目录下的 _config.yml 文件, 在文件末尾修改配置文件：</p><pre class=" language-none"><code class="language-none">deploy:  type: git  repo: github上对应仓库的ssh 链接      //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git              branch: main</code></pre><p><strong>说明：</strong>仓库的ssh链接如下</p><p><img src="/2022/08/27/xiao-bai-jiao-xiao-bai-zhi-bo-ke-da-jian/3.jpg" alt="img"></p><p><strong>切记：分支branch切记修改为 main，之前github的默认主分支为master，现已经改为main</strong> ！</p></li><li><p>第三步：在博客目录下, 将本地 blog 推送到 github仓库</p><p>输入命令：<code>hexo d</code></p><p>也可能需要输入 username &amp; pwd</p><p>推送成功后, 在浏览器中输入对应域名, 即可访问</p><p><strong>至此，你便初步搭建好了一个属于自己的博客！（本地服务不用启动依然可以访问）</strong></p></li><li><p><strong>hexo 框架常用的指令：</strong></p><table><thead><tr><th align="left">指令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>hexo clean &amp;&amp; hexo g</code></td><td align="left">清除本地项目并重新生成 （重新部署时使用）</td></tr><tr><td align="left"><code>hexo g</code></td><td align="left">重新生成</td></tr><tr><td align="left"><code>Hexo s</code></td><td align="left">开启本地预览</td></tr><tr><td align="left"><code>Hexo d</code></td><td align="left">推送到github</td></tr></tbody></table></li></ul><h2 id="四、Hexo-博客的美化"><a href="#四、Hexo-博客的美化" class="headerlink" title="四、Hexo 博客的美化"></a>四、Hexo 博客的美化</h2><p>​        根据自己的特定需要网上搜寻教程即可。</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ol><li><p>theme-matery 主题官方使用说明 <a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p></li><li><p><a href="https://laughingtiger.gitee.io/2021/11/29/ru-he-kuai-su-da-jian-shu-yu-zi-ji-de-bo-ke/">https://laughingtiger.gitee.io/2021/11/29/ru-he-kuai-su-da-jian-shu-yu-zi-ji-de-bo-ke/</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=df70199ed9e748e3043b11859e7a6050">https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=df70199ed9e748e3043b11859e7a6050</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
